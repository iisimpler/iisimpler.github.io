<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>必备知识</title>
      <link href="/2020/07/08/%E4%BA%A7%E5%93%81/%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/07/08/%E4%BA%A7%E5%93%81/%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="产品经理必知"><a href="#产品经理必知" class="headerlink" title="产品经理必知"></a>产品经理必知</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>Axure、Xmind、OmniGraffle、visio、Excel、Word、PPT</p><h4 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h4><p>1用户需求调研、分析、整理、管理</p><p>2）两个框架（功能框架、信息架构），三个流程（业务流程、页面流程、功能流程）</p><p>3）输出原型</p><p>4）撰写PRD（需求文档）、MRD（市场需求说明书）</p><p>5）推进产品开发、上线</p><p>6）产品运营</p><p>工作步骤：了解梳理需求；梳理流程，绘制流程，撰写文档，配合原型，用需求方沟通，确定方案是否可行；技术团队开会，确定技术上是否可行，研发的难度，大致评估一下工期；需求立项；需求方项目验收；上线。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="1）产品生命周期"><a href="#1）产品生命周期" class="headerlink" title="1）产品生命周期"></a>1）产品生命周期</h5><p>初创期—成长期—成熟期—衰退期</p><h5 id="2）客户生命周期"><a href="#2）客户生命周期" class="headerlink" title="2）客户生命周期"></a>2）客户生命周期</h5><p>关系建立—关系发展—关系维系—关系破裂</p><h5 id="3）用户生命周期"><a href="#3）用户生命周期" class="headerlink" title="3）用户生命周期"></a>3）用户生命周期</h5><p>导入期—成长期—成熟期—休眠期—流失期</p><h5 id="4）软件生命周期"><a href="#4）软件生命周期" class="headerlink" title="4）软件生命周期"></a>4）软件生命周期</h5><p>可行性分析与项目开发计划—需求分析—设计—编码—测试—发布和维护</p><h5 id="5）项目生命周期"><a href="#5）项目生命周期" class="headerlink" title="5）项目生命周期"></a>5）项目生命周期</h5><p>规划阶段—设计阶段—实施阶段—完成阶段</p><h4 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h4><h5 id="1）产品经理相关术语"><a href="#1）产品经理相关术语" class="headerlink" title="1）产品经理相关术语"></a>1）产品经理相关术语</h5><p><strong>BRD</strong>：Business Requirement Document 商业需求文档，回答的是产品价值是什么，即这个产品解决了什么问题。（受众：老板，投资人，股东，目的是让他们知道这个产品如何给公司盈利；侧重点是需求描述，盈利模式）</p><p><strong>MRD</strong>：Market Requirement Document 市场需求文档，回答的市场上有哪些同类竞品（竞争格局）、为什么我们公司适合做这个产品（竞争优势），我们产品成功的机会多大（市场机会）。（受众：老板，运营，市场销售，主要是让运营和销售指导相对于竞品，我们产品的优势是什么，更好的向用户介绍产品优点；侧重点在竞品情况以及能为用户带来的便利）</p><p><strong>PRD</strong>：Product Requirement Document 产品需求文档，回答的问题时我们的产品方案是什么，也就是这个产品的具体细节。（受众：开发人员，目的是让开发知道如何把需求按照产品经理的思路开发；侧重点是需求描述、需求逻辑、需求原型）</p><p><strong>B2C</strong>：企业对个人，平台的一端为商家一端为普通用户，如京东和天猫。</p><p><strong>B2B</strong>：企业对企业，平台交易的双方都是商家，比如阿里巴巴。</p><p><strong>C2C</strong>：个人对个人，平台交易的双方都是普通用户，如淘宝、咸鱼、转转。</p><h5 id="2）项目相关的术语"><a href="#2）项目相关的术语" class="headerlink" title="2）项目相关的术语"></a>2）项目相关的术语</h5><p><strong>项目排期表</strong>：为了保证项目按时上线，会使用项目排期表定好每个参与方的具体工作内容，以及起止时间。</p><p><strong>敏捷开发</strong>：是把一个产品，拆分成若干个部分，然后迭代式推进，一点一点往前拱，每次迭代目标清晰，不要求一步到位解决用户的全部问题，小步快跑，快速检验，不断重构，在实践和迭代的过程中去发现问题，并解决问题，同时积累宝贵的经验。</p><p><strong>需求评审</strong>：由项目经理组织产品经理、研发、测试、UI听产品经理讲解需求的过程。</p><h5 id="3）开发技术术语"><a href="#3）开发技术术语" class="headerlink" title="3）开发技术术语"></a>3）开发技术术语</h5><p><strong>接口</strong>：就是后端将数据源和数据库给外部应用去调用的一段程序。</p><p><strong>接口文档</strong>：有哪些接口，分别能干嘛，分别在哪些地方利用；以及清楚的知道每个字段是的含义，是否有疑问；捋清楚整个流程，关注关联两个接口的字段。</p><p><strong>并发量</strong>：有多少用户在同时使用产品，请求数据。</p><p><strong>丢包</strong>：数据在上报过程中，由于网络异常导致的数据丢失。</p><p><strong>组件</strong>：功能集合。</p><p><strong>框架</strong>：基本功能，可扩展。</p><p><strong>DOM</strong>：Document Object Model 即文档对象模型。</p><p><strong>Cookie</strong>：服务器嘿客户端的凭证。</p><p><strong>Session</strong>：会话信息，随机产生的字符串。</p><p><strong>Token</strong>：令牌，UID+时间戳+设备号+自定义规则经过算法加密后的一串字符串，如订单号。</p><h5 id="4）测试相关术语"><a href="#4）测试相关术语" class="headerlink" title="4）测试相关术语"></a>4）测试相关术语</h5><p><strong>提测</strong>：指研发开发完后，打包提交给测试人员开始测试。</p><p><strong>复现</strong>：指将测试出现的bug，再次出现。</p><p><strong>测试用例</strong>：指测试人员根据产品的PRD撰写的测试流程及事项。</p><p><strong>功能测试</strong>：单一功能的测试，比如本迭代要做一个分享功能，功能测试是只测试分享功能是否符合产品要求。</p><p><strong>回归测试</strong>：可以理解为整体测试。本迭代要上线一个分享功能，要测试一下这个功能有没有影响其他功能的正常使用。</p><p><strong>测试报告</strong>：测试完成之后，测试人员撰写的说明BUG均已修复，可以上线的邮件。</p><h5 id="5）广告的相关术语"><a href="#5）广告的相关术语" class="headerlink" title="5）广告的相关术语"></a>5）广告的相关术语</h5><p><strong>搜索广告</strong>：如百度的竞价广告。商家竞价购买关键词。</p><p><strong>展示类广告</strong>：信息类网站中的Banner、竖边、通栏等广告位。</p><p><strong>开屏广告</strong>：APP启动后的全屏广告，如知乎、豆瓣等。</p><p><strong>信息流广告</strong>：以文章、图片、视频等形式插入在信息列表中的广告，常见于内容类的产品，比如今日头条中经常出现的并标识了“广告”字眼的信息。</p><p><strong>视频广告</strong>：如在爱奇艺、优酷等视频网站，在播放前和播放过程中都出现的广告形式。</p><p><strong>SEM</strong>：Search Engine Marketing 即搜索引擎营销，就是根据用户受用搜索引擎的方式利用用户检索信息的机会尽可能将营销信息传递给目标用户。是搜索引擎中竞价排名的优化，需要花钱的。如搜索华为，华为官网的广告想要排在前几位且标识为广告的是需要给钱的，就是SEM。</p><p><strong>SEO</strong>：Search Engine Optimization，即搜索引擎优化，利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名，是免费的。</p><h6 id="常见的广告计费模式"><a href="#常见的广告计费模式" class="headerlink" title="常见的广告计费模式"></a>常见的广告计费模式</h6><p><strong>CTR</strong>：（Click-Through-Rate）即点击通过率，是互联网广告常用的术语，指网络广告（图片广告/文字广告/关键词广告/排名广告/视频广告等）的点击到达率，即该广告的实际点击次数（严格的来说，可以是到达目标页面的数量）除以广告的展现量（Show content）。<br>计算公式为CTR=实际点击次数/展示量，</p><p><strong>CPM</strong>：按其那次展示收费，只要曝光就收费，不管点击、下载或注册等后续流程，适合想要扩大知名度做品牌广告的广告主。</p><p><strong>CPC</strong>：按点击收费，用户点击时才开始计费，常见于竞价排名广告以及信息流广告。</p><p><strong>CPA</strong>：按用户行动收费，下载、安装、购买、注册等形式，适合APP下载、增加新用户等需要明确转化动作的广告主。</p><h5 id="6）运营相关专业术语"><a href="#6）运营相关专业术语" class="headerlink" title="6）运营相关专业术语"></a>6）运营相关专业术语</h5><p><strong>AARRR模型</strong>：Acquisition、Activation、Retention、Revenue、Refer分别为获取用户、提高活跃度、提高留存率、获取收入、自传播。</p><p><strong>RFM用户模型</strong>：Recency表示客户最近一次购买的时间有多远，Frequency表示客户在最忌一段时间内购买的次数，Monetary表示客户在最近一段时间内购买的金额。</p><p><strong>用户增长的S型曲线、J型曲线</strong>：在产品发展周期中，都会遵循S型曲线的增长方式，但有些产品，可能会产生J型曲线。</p><p><strong>拉新</strong>：获取新用户。</p><p><strong>留存</strong>：让用户留在平台，持续使用产品。</p><p><strong>促活</strong>：让用户活跃起来。让用户多生产内容，多消费内容。</p><p><strong>LTV</strong>：life time value，即用户生命周期总价值，一个用户从注册到最终流失的整个过程中贡献的总价值。</p><p><strong>CAC</strong>：Customer Acquisition Cost，即用户获取成本，也就是获取一个新用户需要花多少钱。</p><p><strong>GMV</strong>：Gross Merchandise Volume，即一段时间内的成交总额，包含付款和未付款的部分。电商行业最常用的核心数据指标。</p><h5 id="7）数据分析相关"><a href="#7）数据分析相关" class="headerlink" title="7）数据分析相关"></a>7）数据分析相关</h5><p><strong>PV</strong>：页面访问量，同一个账号访问同一个页面两次，PV算2次。</p><p><strong>UV</strong>：页面访问人数，同一个账号访问同一个页面2次，UV算一次。</p><p><strong>DAU</strong>：日活跃指数，是指一天内打开APP的用户数。</p><p><strong>MAU</strong>：月活跃指数，指一个月内打开APP的用户数。</p><p><strong>留存率</strong>：新增用户中，持续出现的比例。</p><p><strong>次日留存</strong>、<strong>7日留存</strong></p><p><strong>获客渠道</strong>：获取新用户的渠道。</p><h5 id="8）常见规律概念"><a href="#8）常见规律概念" class="headerlink" title="8）常见规律概念"></a>8）常见规律概念</h5><p><strong>马太效应</strong>：指强者愈强、弱者愈弱、好的愈好，坏的愈坏，多的愈多，少的愈少的现象。</p><p><strong>羊群效应</strong>：即从众效应，指人们经常受到多数人的影响，从而跟从大众的思想或行为。因为羊群效应会帮助商家获利，所以在宣传方面商家也在极力诱导羊群效应的产生。</p><p><strong>霍桑效应</strong>：霍桑效应就是当人们意识到自己正在被关注时，会不自觉的去改变自己的某种行为和语言。夸奖和鼓励可以造就一个人；你认为自己是什么样的人，你就可以成为什么样的人。</p><p><strong>病毒式营销</strong>：常用于进行网站推广、品牌推广等，利用用户口碑传播的原理，即人群裂变，福利裂变、情感裂变。</p><p><strong>鲶鱼效应</strong>：指采取一些措施或手段，刺激一些企业活跃起来投入到市场中积极参与竞争，从而激活市场中的同行业企业。</p><p><strong>沸水理论</strong>：即想要保持沸水现状，其供暖成本很高，缺无法带来更多的利益。在做产品时需思考，每个用户活跃的背后，到底对平台意味着什么价值。</p><p><strong>长尾理论</strong>：由于成本和效率的因素，看似需求极低的产品，只要有卖，都会有人买。这些需求和销量不高的产品所占据的共同市场份额，可以和主流市场的份额相比，甚至更大。如销售畅销书和小众图书。</p><p><strong>幸存者偏差</strong>：是指只能看到经过某种筛选而产生的结果，而没有意识到筛选的过程，因此忽略掉了被筛选的关键信息。</p><p><strong>墨菲定律</strong>：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。</p><p><strong>摩尔定律</strong>：当价格不变时，<a href="https://baike.baidu.com/item/集成电路/108211" target="_blank" rel="noopener">集成电路</a>上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。</p><p><strong>黑天鹅事件</strong>：指非常难易预测，且不寻常的事件，通常会引起市场连锁负面反应甚至颠覆。</p><p><strong>囚徒困境</strong>：即个人最佳选择并非团体最佳选择，即，一个群体中，个人呕出理性选择却往往导致集体的非理性。</p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><p>CSV格式，即以逗号分隔的纯文本，如（1,2,3）</p><p>TSV格式，即以table分隔的纯文本，如（1tabel2tabel3）</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 虚拟机类加载机制</title>
      <link href="/2019/12/02/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/12/02/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-虚拟机类加载机制"><a href="#Java-虚拟机类加载机制" class="headerlink" title="Java 虚拟机类加载机制"></a>Java 虚拟机类加载机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><p>Java语言里面类型的加载、连接和初始化过程都是在程序运行期完成的，虽类加载慢但是灵活性更高 — 动态扩展。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><h3 id="类加载生命周期："><a href="#类加载生命周期：" class="headerlink" title="类加载生命周期："></a>类加载生命周期：</h3><blockquote><p>-XX:+TraceClassLoading 打印类加载过程</p></blockquote><p>7个阶段可能互相交叉地混合执行，其中验证、准备和解析统称为连接（Linking）；加载、验证、准备、初始化和卸载5个阶段是固定的，而解析阶段不一定，可能会在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（动态绑定或晚期绑定）。</p><p>虚拟机规范只规定了必须初始化的5种情况：</p><blockquote><p>主动调用类</p></blockquote><ul><li>遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，也即是new对象、读取或设置非final修饰的静态字段、以及调用一个类的静态方法时。</li><li>使用 java.lang,reflect 包的方法对类进行反射调用的时候。</li><li>正在初始化类的父类（接口不需要父接口都完成了初始化）</li><li>包含main方法的类</li><li>使用JDK1.7的动态语言支持时，java.lang.invoke.MethodHandle 实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic 方法句柄所对应的类</li></ul><h4 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h4><blockquote><p>常量传播优化</p></blockquote><ul><li>通过类的全限定名获取二进制字节流<ul><li>注意此处没有注明获取方式和来源，可以是ZIP压缩包，如JAR、WAR；可以是网络，如Applet；可以是运行时计算生成，如动态代理技术，通过ProxyGenerator.generateProxyClass 为特定接口生成形式为 “*$Proxy” 的代理类的二进制流；由其他文件生成，如JSP；…</li></ul></li><li>将字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在方法区生成一个代表此类的 <code>java.lang.Class</code> 对象作为此类的访问入口</li><li>数组类由Java虚拟机直接创建，递归使用类加载器加载组件类型，然后被标记当前类名称空间。</li></ul><h4 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h4><p>连接阶段第一步，确保Class文件内容符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><ul><li>文件格式验证</li></ul><blockquote><p>验证字节流，此阶段通过会存储于方法区</p></blockquote><pre><code>- 是否以魔数0xCAFEBABE开头- 主、次版本号是否在当前虚拟机处理范围之内- 常量池的常量是否有不被支持的类型- CONSTANT_Utf8_info常量中是否有不符合UTF8编码的数据- Class文件中各个部分及文件本身是否有被删除的或附加的其他信息- ......</code></pre><ul><li>元数据验证</li></ul><blockquote><p>语义分析</p></blockquote><pre><code>- 是否有父类（出了java.lang.Object类都应该有父类）- 是否继承了不被允许继承的类（final修饰）- 非抽象类是否实现了接口或父类要求实现的方法- 是否存在字段、方法与父类产生矛盾，如覆盖final字段- ......</code></pre><ul><li>字节码验证</li></ul><blockquote><p>通过数据流和控制流分析，确定语义是合法的、符合逻辑的，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。由于此阶段太复杂太耗时间，JDK 1.6在Code属性中提供了StackMapTable属性。</p></blockquote><pre><code>- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作- 保证跳转指令不会跳转到方法以外的字节码指令- 保证方法类的类型转换是有效的</code></pre><ul><li>符号引用验证</li></ul><blockquote><p>虚拟机将符号引用转化直接引用时，对自身以外（常量池中的各种符号引用）的信息进行匹配性校验。如果对所运行的类已经反复使用和验证过则可以考虑通过参数<code>-Xverify:none</code>关闭此阶段验证，以缩短类加载的时间。</p></blockquote><pre><code>- - 符号引用中是否能通过全限定名找到对应的类- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段- 符号引用中的类、字段、方法的访问性是否可以被当前类访问- ...</code></pre><h4 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a>准备（Preparation）</h4><p>准备阶段是正式为类变量分配方法区的内存并设置初始值的阶段</p><ul><li>非final静态变量设置为零值，在初始化阶段再初始化为给定值</li><li>final变量，则直接初始化为给定值</li></ul><h4 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h4><blockquote><p>将常量池中的符号引用替换成直接引用，解析动作主要针对类或接口（CONSTANT_Class_info）、 字段（CONSTANT_Fieldref_info）、 类方法（CONSTANT_Methodref_info）、 接口方法（CONSTANT_InterfaceMethodref_info）、 方法类型（CONSTANT_MethodType_info）、 方法句柄（CONSTANT_MethodHandle_info）和调用点限定符 （CONSTANT_Dynamic_info）7 种符号引用进行。</p></blockquote><ul><li>符号引用</li></ul><p>任何形式的字面量可描述所引用的目标，与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。</p><ul><li>直接引用</li></ul><p>直接指向目标的指针、相对偏移量或者是一个能简介定位到目标的句柄，与虚拟机实现的内存布局相关，引用的目标一定已经加载到内存中。</p><h4 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h4><blockquote><p>到此真正执行类中定义的Java程序代码，初始化阶段是执行类构造器 <code>&lt;client&gt;()</code> 方法的过程</p></blockquote><ul><li><p><code>&lt;client&gt;()</code> 方法时由编译器自动收集类中的所以 类变量的复制动作和静态语句块中的语句合并产生的，收集顺序取决于语句在源文件中的顺序。静态代码块中只能访问到定义在静态语句块之前的变量，静态代码块只能对出现在后面的变量进行赋值不能访问。</p></li><li><p>虚拟机会保证父类中的 <code>&lt;client&gt;()</code> 方法先执行，也就意味着父类的静态语句块优先于子类的变量赋值操作。</p></li><li><p><code>&lt;client&gt;()</code> 不是必需的，如果一个类既没有静态代码块也没有对变量的赋值操作这可以不用生成。</p></li><li><p><code>&lt;client&gt;()</code> 的执行必需加锁，在同一个类加载器中只能初始化一次。</p></li></ul><h4 id="使用（Using）"><a href="#使用（Using）" class="headerlink" title="使用（Using）"></a>使用（Using）</h4><h4 id="卸载（Unloading）"><a href="#卸载（Unloading）" class="headerlink" title="卸载（Unloading）"></a>卸载（Unloading）</h4><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>每一个类加载器加载的类都有独有的命名空间，所以不同的类加载器加载的同一个类也不相等，这里指equals()、 isAssignableFrom()、isInstance()、instanceof等关键字判断的所属关系。</p><h3 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h3><p>java 虚拟机只存在两种不同类加载器：一种是Bootstrap ClassLoader；另一种是其它所有类加载器，全部继承自 <code>java.lang.ClassLoader</code>。Bootstrap ClassLoader是虚拟机内部实现的，一般是C++实现（HotSpot）或者C实现（J9和JRockit）。启动类加载器负责将 <code>${JAVA_HOME}/lib</code> 目录中，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中，并且是虚拟机识别的类库加载到虚拟机内存中，如：rt.jar。</p><h3 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h3><p>扩展类加载器由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现，负责加载 <code>${JAVA_HOME}/lib/ext</code> 目录中，或者被 <code>java.ext.dirs</code> 系统变量所指定的路径中的所有类库。</p><h3 id="应用程序类加载器（Application-ClassLoader）"><a href="#应用程序类加载器（Application-ClassLoader）" class="headerlink" title="应用程序类加载器（Application ClassLoader）"></a>应用程序类加载器（Application ClassLoader）</h3><p>应用程序类加载器由 <code>sun.misc.Launcher$AppClassLoader</code> 实现，负责加载用户类路径（ClassPath）上所指定的类库，一般情况下默认就是此加载器。由于这个类加载器是ClassLoader中getSystemClassLoader() 方法的返回值，所以也叫系统类加载器。</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型即是 <code>Bootstrap ClassLoader -&gt; Extension ClassLoader -&gt;Application ClassLoader -&gt; User ClassLoader</code> 除了顶层的 Bootstrap ClassLoader，都应该有父类加载器（通过组合的方式而不是继承）复用父类加载器代码。当一个类加载器收到了类加载请求，它不会自己去尝试加载这个类，而是把这个请求委派过父类加载器去加载，只有当父类加载器无法加载时，子加载器才会尝试加载。</p><p>用户自定义类加载器时，不建议覆盖loadClass方法，而应该覆盖findClass()方法，这样可以保证符合双亲委派规则。</p><p>在JNDI、JDBC、JCE、JAXB、JBI等中涉及SPI的加载动作采用了线程上下文类加载器（Thread Context ClassLoader），在初始化Launcher时将当前Application ClassLoader设置到Thread Context中，当BootStrap ClassLoader无法加载到的类中，有一部分可通过Service ClassLoader从Thread Context中获取Application ClassLoader加载在 <code>META-INF/services/*</code>下定义的类，这其实没有遵守双亲委派模型。</p><p>在OSGI环境中，每个模块都有一个自己的类加载器，类加载器不再是双亲委派的树状结构，而是进一步发展为更加复杂的网状结构。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> 类加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 类文件结构</title>
      <link href="/2019/11/23/Java/Java%20%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2019/11/23/Java/Java%20%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-类文件结构"><a href="#Java-类文件结构" class="headerlink" title="Java 类文件结构"></a>Java 类文件结构</h1><blockquote><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p></blockquote><p>Java 虚拟机在<strong>字节码格式</strong>标准的基础上对下实现了平台无关性，对上实现了语言无关性。所以Java 规范文档分为 Java 语言规范《The Java Language Specification》和Java 虚拟机规范《The Java Virtual Machine Specification》。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Class 文件是一组以 8 字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，当某个数据项超过 8 字节时则按照高位（Big-Endian）在前的方式分隔若干个 8 字节存储。</p><p>Class 文件结构分为两种数据类型：</p><ul><li><p>无符号数<br>无符号数属于基本的数据类型，用来描述数字、索引引用、常量值或者按照 UTF-8 编码构成的字符串值。以u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数。</p></li><li><p>表<br>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都以“_info”结尾。整个 Class 文件本质上是一张表。</p></li></ul><p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时会使用一个前置的容量计数器加若干个连续的数据项形式，这时称这一系列的数据为某一类型的集合。</p><h2 id="ClassFile-结构"><a href="#ClassFile-结构" class="headerlink" title="ClassFile 结构"></a>ClassFile 结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>magic</li></ul><p>Magic 唯一作用是确定这个文件是否为一个能被虚拟机所接受的 Class 文件。魔数值固定为 <code>0xCAFEBABE</code>，不会改变。</p><ul><li>minor_version 和 major_version</li></ul><p>minor_version 和 major_version 值分别表示 Class 文件的副、主版本。高版本 JDK 向下兼容低版本 Class 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Java 版本号是从 45 开始的</span><br><span class="line">JDK 1.0~1.11.21.31.41.51.61.71.8</span><br><span class="line">major_version 45.0~45.3 46474849505152</span><br></pre></td></tr></table></figure><ul><li>constant_pool</li></ul><p>常量池是 Class 文件的常量统一存放的表类型数据项目。以一个 u2 类型的数据存储常量池容量计数值（constant_pool_count），后续紧跟常量池，常量从 1 开始（0 表示不引用任何常量）。</p><p>常量池中主要存放两类常量， 字面量（Literal）和符号引用（Symbolic Reference）。字面量接近 Java 语言层面的常量概念，如文本字符串、声明为 final 的常数值。符号引用<br>编译原理方面的概念，包括<strong>类和接口的全限定名（Fully Qualified Name）</strong>，<strong>字段的名称和描述符（Descriptor）</strong>， <strong>方法的名称和描述符</strong>。</p><p>每个常量都具有如下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u1 info[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Constant Type</th><th>Value</th><th>description</th></tr></thead><tbody><tr><td><code>CONSTANT_Utf8</code></td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td><code>CONSTANT_Integer</code></td><td>3</td><td>整形字面量</td></tr><tr><td><code>CONSTANT_Float</code></td><td>4</td><td>浮点型字面量</td></tr><tr><td><code>CONSTANT_Long</code></td><td>5</td><td>长整型字面量</td></tr><tr><td><code>CONSTANT_Double</code></td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td><code>CONSTANT_Class</code></td><td>7</td><td>类或接口的符号引用</td></tr><tr><td><code>CONSTANT_String</code></td><td>8</td><td>字符串类型字面量</td></tr><tr><td><code>CONSTANT_Fieldref</code></td><td>9</td><td>字段的符号引用</td></tr><tr><td><code>CONSTANT_Methodref</code></td><td>10</td><td>类中方法的符号引用</td></tr><tr><td><code>CONSTANT_InterfaceMethodref</code></td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td><code>CONSTANT_NameAndType</code></td><td>12</td><td>字段或方法的部分符号引用</td></tr><tr><td><code>CONSTANT_MethodHandle</code></td><td>15</td><td>表示方法句柄</td></tr><tr><td><code>CONSTANT_MethodType</code></td><td>16</td><td>标识方法句柄</td></tr><tr><td><code>CONSTANT_InvokeDynamic</code></td><td>18</td><td>标识一个动态方法调用点</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;// tag=1</span><br><span class="line">    u2 length;// 字节长度，2字节最大存储65535长度，也就限制了最大存储字符串常量为64K</span><br><span class="line">    u1 bytes[length];// 字节数组，采用 UTF-8 缩略编码（用 1~3 字节来表示）。</span><br><span class="line">// 缩略编码和标准的 UTF-8 编码区别：</span><br><span class="line">// 第一：前者用双字节格式编码表示 &apos;null&apos; 而不是单字节</span><br><span class="line">// 第二：前者在表示 4 字节字符时用两个三字节格式代替</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    u1 tag;// tag=3</span><br><span class="line">    u4 bytes;// 表示int常量的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_Float_info &#123;</span><br><span class="line">    u1 tag;// tag=4</span><br><span class="line">    u4 bytes;// 表示float常量的值，采用IEEE 754单精度浮点格式</span><br><span class="line">// 首先将 bytes 转换为 int 常量的 bits：</span><br><span class="line">// 如果 bits=0x7f800000, float值=正无穷大；</span><br><span class="line">// 如果 bits=0xff800000, float值=负无穷大；</span><br><span class="line">// 如果 bits范围为 0x7f800000~0x7fffffff和0xff800001~0xfffffff, float值为NaN</span><br><span class="line">// 其他情况下，根据以下方式计算</span><br><span class="line">// int s = ((bits &gt;&gt; 31) == 0) ? 1 : -1;</span><br><span class="line">// int e = ((bits &gt;&gt; 23) &amp; 0xff);</span><br><span class="line">// int m = (e == 0) ? (bits &amp; 0x7fffff) &lt;&lt; 1 : (bits &amp; 0x7fffff) | 0x800000;</span><br><span class="line">// float值 = s·m·2^(e-150)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在 class 文件的常量池表中，所有 8 字节常量均占用两个表成员的空间，只占用第一个，第二个必须不可用</span><br><span class="line">CONSTANT_Long_info &#123;</span><br><span class="line">    u1 tag;// tag=5</span><br><span class="line">    u4 high_bytes;// 表示Long常量的高位</span><br><span class="line">    u4 low_bytes;// 表示Long常量的低位</span><br><span class="line">// Long值 = ((long)high_bytes &lt;&lt; 32) + low_bytes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_Double_info &#123;</span><br><span class="line">    u1 tag;// tag=6</span><br><span class="line">    u4 high_bytes;// 表示Double常量的高位，采用IEEE 754双精度浮点格式</span><br><span class="line">    u4 low_bytes;// 表示Double常量的低位，采用IEEE 754双精度浮点格式</span><br><span class="line">// Double值 = ((long)high_bytes &lt;&lt; 32) + low_bytes</span><br><span class="line">// 如果 bits=0x7ff0000000000000L, double值=正无穷大</span><br><span class="line">// 如果 bits=0xfff0000000000000L, double值=负无穷大</span><br><span class="line">// 如果 bits范围在0x7ff0000000000001L~0x7fffffffffffffffL 或者 0xfff0000000000001L~0xffffffffffffffffL，double值为NaN</span><br><span class="line">// 其他情况下，根据以下方式计算</span><br><span class="line">// int s = ((bits &gt;&gt; 63) == 0) ? 1 : -1;</span><br><span class="line">// int e = (int)((bits &gt;&gt; 52) &amp; 0x7ffL);</span><br><span class="line">// long m = (e == 0) ?</span><br><span class="line">//           (bits &amp; 0xfffffffffffffL) &lt;&lt; 1 :</span><br><span class="line">//           (bits &amp; 0xfffffffffffffL) | 0x10000000000000L;</span><br><span class="line">// double值 = s·m·2^(e-1075)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag; // tag=7</span><br><span class="line">    u2 name_index; // 常量池索引，索引处必须是CONSTANT_Utf8_info结构表示类名或接口名</span><br><span class="line">    // 二维数组int[][]类名表示为 [[I，维度必须小于等于 255</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_String_info &#123;</span><br><span class="line">    u1 tag;// tag=8</span><br><span class="line">    u2 string_index;// 常量池索引，索引处必须是CONSTANT_Utf8_info表示字符串常量对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">    u1 tag;// tag=9</span><br><span class="line">    u2 class_index;// 常量池索引，索引处必须是CONSTANT_Class_info结构表示类或接口</span><br><span class="line">    u2 name_and_type_index;// 常量池索引，索引处必须是CONSTANT_NameAndType_info结构表示字段描述符</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">    u1 tag;// tag=10</span><br><span class="line">    u2 class_index;// 常量池索引，索引处必须是CONSTANT_Class_info结构表示类</span><br><span class="line">    u2 name_and_type_index;// 常量池索引，索引处必须是CONSTANT_NameAndType_info结构表示方法描述符</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_InterfaceMethodref_info &#123;</span><br><span class="line">    u1 tag;// tag=11</span><br><span class="line">    u2 class_index;// 常量池索引，索引处必须是CONSTANT_Class_info结构表示接口</span><br><span class="line">    u2 name_and_type_index;// 常量池索引，索引处必须是CONSTANT_NameAndType_info结构表示方法描述符</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_NameAndType_info &#123;</span><br><span class="line">    u1 tag;// tag=12</span><br><span class="line">    u2 name_index;// 常量池索引，索引处必须是CONSTANT_Utf8_info结构表示方法或者字段的非限定名</span><br><span class="line">    u2 descriptor_index;// 常量池索引，索引处必须是CONSTANT_Utf8_info结构表示字段描述符和方法描述符</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_MethodHandle_info &#123;</span><br><span class="line">    u1 tag;// tag=15</span><br><span class="line">    u1 reference_kind;// 表示方法句柄类型 1~9</span><br><span class="line">    u2 reference_index;// 常量池索引，索引处结构要求见下表</span><br><span class="line">&#125;</span><br><span class="line">// 方法句柄类型 1~9</span><br><span class="line">// 1REF_getFieldgetfield C.f:T</span><br><span class="line">// 2REF_getStaticgetstatic C.f:T</span><br><span class="line">// 3REF_putFieldputfield C.f:T</span><br><span class="line">// 4REF_putStaticputstatic C.f:T</span><br><span class="line">// 5REF_invokeVirtualinvokevirtual C.m:(A*)T</span><br><span class="line">// 6REF_invokeStaticinvokestatic C.m:(A*)T</span><br><span class="line">// 7REF_invokeSpecialinvokespecial C.m:(A*)T</span><br><span class="line">// 8REF_newInvokeSpecialnew C; dup; invokespecial C.&lt;init&gt;:(A*)V</span><br><span class="line">// 9REF_invokeInterfaceinvokeinterface C.m:(A*)T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CONSTANT_MethodType_info &#123;</span><br><span class="line">    u1 tag;// tag=16</span><br><span class="line">    u2 descriptor_index;// 常量池索引，索引处必须是CONSTANT_Utf8_info结构表示方法的描述符</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_InvokeDynamic_info &#123;</span><br><span class="line">    u1 tag;// tag=18</span><br><span class="line">    u2 bootstrap_method_attr_index;// 对引导方法表的bootstrap_methods数组的索引</span><br><span class="line">    u2 name_and_type_index;// 常量池索引，索引处必须是CONSTANT_NameAndType_info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>access_flags</li></ul><div class="table-container"><table><thead><tr><th>Flag名称</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>声明为 public， 可以用包外访问</td></tr><tr><td><code>ACC_FINAL</code></td><td>0x0010</td><td>声明为 final，不允许有子类</td></tr><tr><td><code>ACC_SUPER</code></td><td>0x0020</td><td>当用到 invokespecial 指令时，需要对父类方法做特殊处理，必须为真</td></tr><tr><td><code>ACC_INTERFACE</code></td><td>0x0200</td><td>该 class 文件定义的是接口而不是类</td></tr><tr><td><code>ACC_ABSTRACT</code></td><td>0x0400</td><td>声明为 abstract，不能被实例化</td></tr><tr><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>声明为 synthetic， 表示该 class 文件并非由 Java 源代码所生成</td></tr><tr><td><code>ACC_ANNOTATION</code></td><td>0x2000</td><td>标识注解类型</td></tr><tr><td><code>ACC_ENUM</code></td><td>0x4000</td><td>标识枚举类型</td></tr></tbody></table></div><ul><li>this_class</li></ul><p>类索引（this class）用于确定当前类的全限定名。常量池索引，索引处必须是CONSTANT_Class_info结构。</p><ul><li>super_class</li></ul><p>父类索引（super_class）用于确定当前类的父类全限定名。常量池索引，索引处必须是CONSTANT_Class_info结构。</p><ul><li>interfaces</li></ul><p>接口表（interfaces）描述当前类所实现的接口集合。每个成员必须是常量池索引，索引处必须是CONSTANT_Class_info结构。</p><ul><li>fields</li></ul><p>字段表（fields）描述当前类或接口中某个字段的完整描述。每个成员必须是常量池索引，索引处必须是fields_info结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             name_index;//常量池索引，索引处必须是CONSTANT_Utf8_info结构表示非限定名</span><br><span class="line">    u2             descriptor_index;//常量池索引，索引处必须是CONSTANT_Utf8_info结构表示字段描述符</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>access_flags</th><th>value</th><th>含义</th></tr></thead><tbody><tr><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>声明为<code>public</code>，可以从包外访问</td></tr><tr><td><code>ACC_PRIVATE</code></td><td>0x0002</td><td>声明为<code>private</code>，只能在定义该字段的类中访问</td></tr><tr><td><code>ACC_PROTECTED</code></td><td>0x0004</td><td>声明为<code>protected</code>，可以在子类中访问</td></tr><tr><td><code>ACC_STATIC</code></td><td>0x0008</td><td>声明为<code>static</code>.</td></tr><tr><td><code>ACC_FINAL</code></td><td>0x0010</td><td>声明为<code>final</code>，对象构造好后就不能直接设置该字段了</td></tr><tr><td><code>ACC_VOLATILE</code></td><td>0x0040</td><td>声明为<code>volatile</code>，被标识的字段无法缓存</td></tr><tr><td><code>ACC_TRANSIENT</code></td><td>0x0080</td><td>声明为<code>transient</code>，被标识的字段不会被持久化管理器所读取或写入</td></tr><tr><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>声明为synthetic，不是源代码提供的，是由编译器自动产生的</td></tr><tr><td><code>ACC_ENUM</code></td><td>0x4000</td><td>声明为某个枚举类型</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><em>FieldType</em> term</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td><code>B</code></td><td><code>byte</code></td><td>signed byte</td></tr><tr><td><code>C</code></td><td><code>char</code></td><td>基于多文种的 Unicode 字符码点，UTF-16 编码</td></tr><tr><td><code>D</code></td><td><code>double</code></td><td>双精度浮点数</td></tr><tr><td><code>F</code></td><td><code>float</code></td><td>单精度浮点数</td></tr><tr><td><code>I</code></td><td><code>int</code></td><td>整型数</td></tr><tr><td><code>J</code></td><td><code>long</code></td><td>长整型</td></tr><tr><td><code>L</code> <em>ClassName</em> <code>;</code></td><td><code>reference</code></td><td><em>ClassName</em> 的实例</td></tr><tr><td><code>S</code></td><td><code>short</code></td><td>signed short</td></tr><tr><td><code>Z</code></td><td><code>boolean</code></td><td>布尔值 true/false</td></tr><tr><td><code>[</code></td><td><code>reference</code></td><td>one array dimension</td></tr></tbody></table></div><ul><li>methods</li></ul><p>方法表（methods）用于表示当前类或接口中某个方法的完整描述。每个成员必须是常量池索引，索引处必须是method_info结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             name_index;//常量池索引，索引处必须是CONSTANT_Utf8_info结构表示非限定名</span><br><span class="line">    u2             descriptor_index;//常量池索引，索引处必须是CONSTANT_Utf8_info结构表示方法描述符</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>access_flags</th><th>value</th><th>含义</th></tr></thead><tbody><tr><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>声明为<code>public</code>，可以从包外访问</td></tr><tr><td><code>ACC_PRIVATE</code></td><td>0x0002</td><td>声明为<code>private</code>，只能在定义该字段的类中访问</td></tr><tr><td><code>ACC_PROTECTED</code></td><td>0x0004</td><td>声明为<code>protected</code>，可以在子类中访问</td></tr><tr><td><code>ACC_STATIC</code></td><td>0x0008</td><td>声明为<code>static</code></td></tr><tr><td><code>ACC_FINAL</code></td><td>0x0010</td><td>声明为<code>final</code>，不能被覆盖</td></tr><tr><td><code>ACC_SYNCHRONIZED</code></td><td>0x0020</td><td>声明为 <code>synchronized</code>; 该方法将被包装在同步锁里</td></tr><tr><td><code>ACC_BRIDGE</code></td><td>0x0040</td><td>声明为 bridge，由编译器生成的泛型桥接方法</td></tr><tr><td><code>ACC_VARARGS</code></td><td>0x0080</td><td>声明方法带有变长参数</td></tr><tr><td><code>ACC_NATIVE</code></td><td>0x0100</td><td>声明为 <code>native</code>，不是由 java 实现</td></tr><tr><td><code>ACC_ABSTRACT</code></td><td>0x0400</td><td>声明为 <code>abstract</code>，没有实现</td></tr><tr><td><code>ACC_STRICT</code></td><td>0x0800</td><td>声明为 <code>strictfp</code>; 使用 FP-strict 浮点模式</td></tr><tr><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>编译器合成而不是源代码提供的</td></tr></tbody></table></div><ul><li>attributes</li></ul><p>属性表（attributes）描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index;//常量池索引，索引处必须是CONSTANT_Utf8_info结构表示无符号引用</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue 是定长属性， 表示一个被static修饰字段常量表达式的值，位于字段属性表中</span><br><span class="line"></span><br><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">    u2 attribute_name_index; // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “ConstantValue”</span><br><span class="line">    u4 attribute_length;     // 固定为2</span><br><span class="line">    u2 constantvalue_index;  // 常量池索引，索引处必须是CONSTANT_Utf8_info，表示当前常量的值（Entry Type）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> Field Type                     Entry Type</span><br><span class="line"> long                             CONSTANT_Long</span><br><span class="line"> float                          CONSTANT_Float</span><br><span class="line"> double                         CONSTANT_Double</span><br><span class="line"> int, short, char, byte, boolean  CONSTANT_Integer</span><br><span class="line"> String                         CONSTANT_String</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Code属性是变长属性，包含某个方法、实例初始化方法、类或接口初始化方法的Java虚拟机指令及相关辅助信息，位于方法属性表中</span><br><span class="line">如果方法被被abstract、native修饰，不能有code属性</span><br><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;         // 常量池索引，常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “Code”</span><br><span class="line">    u4 attribute_length;             // 属性长度</span><br><span class="line">    u2 max_stack;                    // 当前方法栈在方法执行过程中任何时间点的最大深度</span><br><span class="line">    u2 max_locals;                   // 当前方法局部变量的个数，包括该方法的形参</span><br><span class="line">    u4 code_length;                  // 当前方法字节数组长度，必须大于0，也就是code[]数组不能为空</span><br><span class="line">    u1 code[code_length];            // 当前方法字节数组</span><br><span class="line">    u2 exception_table_length;       // 异常表数量</span><br><span class="line">    &#123;   u2 start_pc;                 // start_pc 和 end_pc 表明了异常处理器在 code[] 中的有效范围</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;               // 异常处理的起点，code[]中的有效索引</span><br><span class="line">        u2 catch_type;               // 如果 catch_type 不为0，则必须是常量池索引，该索引处必须是 CONSTANT_Class_info 结构用于表示异常捕捉类型</span><br><span class="line">                                     // 如果 catch_type 为0， 所有异常都将调用这个异常处理器，可用于实现finally语句</span><br><span class="line">    &#125; exception_table[exception_table_length];   // 异常表数组</span><br><span class="line">    u2 attributes_count;                         // code属性数量</span><br><span class="line">    attribute_info attributes[attributes_count]; // 属性数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StackMapTable 属性是变长属性，用于虚拟机的类型检查验证阶段，位于AttributeCode中</span><br><span class="line"></span><br><span class="line">StackMapTable_attribute &#123;</span><br><span class="line">    u2              attribute_name_index;        // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “StackMapTable”</span><br><span class="line">    u4              attribute_length;            // 属性长度</span><br><span class="line">    u2              number_of_entries;           // entries个数</span><br><span class="line">    stack_map_frame entries[number_of_entries];  // 栈映射帧数组，顺序很重要</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exceptions_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;     // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “Exceptions”</span><br><span class="line">    u4 attribute_length;         // 属性长度</span><br><span class="line">    u2 number_of_exceptions;     // exception_index_table数组长度</span><br><span class="line">    u2 exception_index_table[number_of_exceptions]; // 受检异常类型数组，常量池索引，索引处必须是CONSTANT_Class_info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">InnerClasses 属性是变长属性，位于 ClassFile 中</span><br><span class="line"></span><br><span class="line">InnerClasses_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;  // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “InnerClasses”</span><br><span class="line">    u4 attribute_length;      // 属性长度</span><br><span class="line">    u2 number_of_classes;</span><br><span class="line">    &#123;   u2 inner_class_info_index;  // 常量池索引，索引处必须是CONSTANT_Class_info，用于表示内部类或接口</span><br><span class="line">        u2 outer_class_info_index;  // 常量池索引，索引处必须是CONSTANT_Class_info，用于表示所属类或接口</span><br><span class="line">        u2 inner_name_index;        // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示内部类名称</span><br><span class="line">        u2 inner_class_access_flags;// 内部类访问标志</span><br><span class="line">    &#125; classes[number_of_classes];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EnclosingMethod 属性是可选的定长属性，当且仅当匿名类或内部类才有此属性，位于 &#123;@link me.fanwei.fwm.classfile.ClassFile&#125; 中</span><br><span class="line"></span><br><span class="line">EnclosingMethod_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;  // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “EnclosingMethod”</span><br><span class="line">    u4 attribute_length;      // 固定为4</span><br><span class="line">    u2 class_index;           // 常量池索引，索引处必须是CONSTANT_Class_info，用于表示当前内最内层类</span><br><span class="line">    u2 method_index;          // 如果当前类不是直接包含在某个方法或构造器中，则此字段必须为0，否则常量池索引，索引处必须是CONSTANT_NameAndType_info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Synthetic 属性是定长属性，是为了支持内部类和接口引入的，类、方法、字段结构都会有</span><br><span class="line"></span><br><span class="line">Synthetic_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;     // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “Synthetic”</span><br><span class="line">    u4 attribute_length;         // 固定为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Signature 属性是可选的定长属性，位于类、方法、字段中，任何定义了类型或者包含类型参数时，此属性记录泛型信息，有助于实现反射、调试及编译</span><br><span class="line"></span><br><span class="line">Signature_attribute &#123;</span><br><span class="line">    u2 attribute_name_index; // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “Signature”</span><br><span class="line">    u4 attribute_length;     // 必需为2</span><br><span class="line">    u2 signature_index;      // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示类型签名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SourceFile_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 sourcefile_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SourceDebugExtension_attribute 是可选属性，保存类的扩展调试信息， 位于ClassFile中（一个类最多只能包含一个）</span><br><span class="line"></span><br><span class="line">SourceDebugExtension_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;                 // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “SourceDebugExtension”</span><br><span class="line">    u4 attribute_length;                     //</span><br><span class="line">    u1 debug_extension[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable 是可选的变长属性表，用于给出源文件中行号所表示的内容，位于code结构中</span><br><span class="line"></span><br><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;         // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “LineNumberTable”</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;   u2 start_pc;                 // Code[] 的索引</span><br><span class="line">        u2 line_number;              // 行号</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable 可选变长属性，用于调试器确定变量的值，位于Code属性中</span><br><span class="line"></span><br><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;         // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “LocalVariableTable”</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;   u2 start_pc;                 // code数组起始位置</span><br><span class="line">        u2 length;                   // 长度</span><br><span class="line">        u2 name_index;               // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示局部变量的非限定名</span><br><span class="line">        u2 descriptor_index;         // 当前局部变量在当前栈帧的局部变量的索引</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length]; // 成员都以偏移量的方式给出code数组中某个范围</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTypeTable 属性是可选的变长属性，位于code属性中，与AttributeLocalVariableTable类似</span><br><span class="line"></span><br><span class="line">LocalVariableTypeTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;             // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “LocalVariableTypeTable”</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_type_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 signature_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_type_table[local_variable_type_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deprecated 属性是可选定长属性，位于类、方法、字段的属性表中</span><br><span class="line"></span><br><span class="line">Deprecated_attribute &#123;</span><br><span class="line">    u2 attribute_name_index; // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “Deprecated”</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RuntimeVisibleAnnotations 属性是变长属性，记录运行时注解， 位于类、方法、字段的属性表中，最多只能有一个</span><br><span class="line"></span><br><span class="line">RuntimeVisibleAnnotations_attribute &#123;</span><br><span class="line">    u2         attribute_name_index;         // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “RuntimeVisibleAnnotations”</span><br><span class="line">    u4         attribute_length;</span><br><span class="line">    u2         num_annotations;</span><br><span class="line">    annotation annotations[num_annotations];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AnnotationDefault 属性是变长属性，用来表示注解元素的默认值</span><br><span class="line"></span><br><span class="line">AnnotationDefault_attribute &#123;</span><br><span class="line">    u2            attribute_name_index;</span><br><span class="line">    u4            attribute_length;</span><br><span class="line">    element_value default_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BootstrapMethods属性是变长属性，用于保存由invokedynamic指令引用的引导方法限定符，位于类属性表中</span><br><span class="line"></span><br><span class="line">BootstrapMethods_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;     // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “BootstrapMethods”</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 num_bootstrap_methods;</span><br><span class="line">    &#123;   u2 bootstrap_method_ref;</span><br><span class="line">        u2 num_bootstrap_arguments;</span><br><span class="line">        u2 bootstrap_arguments[num_bootstrap_arguments];</span><br><span class="line">    &#125; bootstrap_methods[num_bootstrap_methods];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MethodParameters 属性是变长属性，记录形参信息，位于方法属性表中</span><br><span class="line"></span><br><span class="line">MethodParameters_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;         // 常量池索引，索引处必须是CONSTANT_Utf8_info，用于表示字符串 “MethodParameters”</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u1 parameters_count;</span><br><span class="line">    &#123;   u2 name_index;</span><br><span class="line">        u2 access_flags;</span><br><span class="line">    &#125; parameters[parameters_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 类结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 垃圾收集器</title>
      <link href="/2019/09/17/Java/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2019/09/17/Java/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-垃圾收集器"><a href="#Java-垃圾收集器" class="headerlink" title="Java 垃圾收集器"></a>Java 垃圾收集器</h1><h2 id="判定对象是否可引用"><a href="#判定对象是否可引用" class="headerlink" title="判定对象是否可引用"></a>判定对象是否可引用</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加一个引用计数器，每当有一次引用计算器加 1，每当引用失效时，计数器就减1，任何时候计数器为 0 的对象就是不可能再被使用应当被回收的。这种算法在微软的 COM（Component Object Model）技术、使用 ActionScript 3的 FlashPlayer 、Python 语言和游戏脚本Squiirrel 中有广泛的应用，但是无法解决 Java 中对象相互依赖的问题。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>顺着一系列的 GC Roots 对象的引用链（Reference Chain）进行搜索，任何无法搜索到的对象就是不可达的，会被判定为不可回收对象。为保证一致性，GC 的搜索过程必须停顿（在安全点或者安全区域，一般采用主动式中断而非抢先式中断）所有 Java 执行线程（Stop The World）。因为主流虚拟机都采用准确式内存管理，所以虚拟机可以使用一组 OopMap 的数据结构快速寻找到引用。</p><p>在 Java 中可作为 GC Roots 的对象包括：</p><ul><li>虚拟机栈中栈帧的本地变量表中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈JNI（即Native 方法）引用的对象</li></ul><hr><p>引用在 JDK 1.2 之前的定义：reference 类型的数据中存储的数值代表的另外一块内存的起始地址。在 JDK 1.2 后，引用的概念被进行了扩充：</p><ul><li>强引用，一般对象赋值就是强引用，永远不会被垃圾收集器回收</li><li>软引用，通过 SoftReference 类实现，当垃圾收集器GC 之后内存仍然紧张就会进行第二次GC 回收这类对象</li><li>弱引用，通过 WeakReference 类实现，一定会被下次 GC 回收掉</li><li>虚引用，通过 PhantomReference 类实现，一定会被下次 GC 回收掉，并且会收到系统通知</li></ul><hr><p>方法区的回收主要回收废弃常量和无用的类。如果一个常量没有被引用则可以被回收；如果一个类所有的实例和加载该类的加载器都被回收且该Class 对象没有被引用（无法通过反射访问）则可以被回收。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>因为对象存活时间不同将内存划分为不同区域，当前商业虚拟机都采用分代收集算法。</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h3><p><img src="/2019/09/17/Java/Java 垃圾收集器/标记 - 清除算法.png" alt="标记 - 清除算法"></p><p>标记 - 清除算法（Mark-Sweep）分为标记和清除两个阶段：首先标记出所有需要回收的对象，然后统一回收被标记的对象。该算法是最基础的收集算法，后续其他收集算法都在此基础上进行改良。不足之处有两个：</p><ul><li>效率问题，标记和清除两个过程效率都不高</li><li>空间问题，标记清除后会产生大量碎片，如果在后续无法找到连续的内存空间分配大对象时不得不提前出发另一次垃圾收集动作。</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/2019/09/17/Java/Java 垃圾收集器/复制算法.png" alt="复制算法"></p><p>将可用内存划分为两个相等的部分，每次只使用其中一部分，当这部分内存用完了就将还存活的对象复制到另一部分内存中，然后将这部分内存一次性全部清理掉，适用于对象存活率较低的情况。这样不用考虑内存碎片的问题，所以当内存分配时可以使用指针碰撞的方式，简单高效。缺点是可用内存只有一半，代价太高，而且在对象存活率较高时效率较低，还需要有额外的空间进行分配担保（Handle Promotion）。</p><p>目前新生代中采用这种算法进行垃圾收集，因为新生代中 98%的对象生存期都比较短，所有不需要按照 1:1 的比例划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 区，当回收时将 Eden 区和使用的 Survivor 区中的存活对象复制到另外一块 Survivor 区。目前 HotSpot 默认 Eden 和 Survivor 比例是 8:1:1，也即是只有 10%的空间会被浪费，如果某次回收存活对象超过了 10%，Survivor 空间不够存放时需要老年代进行分配担保（Handle Promotion）。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h3><p><img src="/2019/09/17/Java/Java 垃圾收集器/标记 - 整理算法.png" alt="标记 - 整理算法"></p><p>标记 - 整理算法（Mark-Compact），分为标记和整理两个阶段：首先标记出所有需要回收的对象，然后让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。对于存活率较高的老年代来说比较合适。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/2019/09/17/Java/Java 垃圾收集器/垃圾收集器搭配.png" alt="垃圾收集器搭配"></p><hr><ul><li><p>并发（Concurrent）<br>指用户线程与垃圾收集线程同时执行（但不一定是并行的，也可能会交替执行）。</p></li><li><p>并行（Parallel）<br>指多条垃圾收集线程并行工作，但此时用户线程处于等待状态。</p></li><li><p>吞吐量（Throughput）<br>CPU 用于运行用户代码的时间与 CPU 总消耗时间（包括运行用户代码时间和垃圾收集时间的总和）的比值。吞吐量越大越适合高效率利用 CPU 时间尽快完成程序的后台运算任务，而不适合交互任务。</p></li><li><p>停顿时间<br>CPU用于完全用于垃圾收集的停顿时间，停顿时间越短越适合在于用户交互的程序中提高良好的响应速度，而不适合后台运算任务。</p></li><li><p>新生代GC（Minor GC）<br>指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p></li><li><p>老年代GC（Major GC / Full GC）<br>指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p></li></ul><hr><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p><img src="/2019/09/17/Java/Java 垃圾收集器/Serial 收集器.png" alt="Serial 收集器"></p><p>单线程新生代收集器，暂停所有工作线程（Stop The World）后使用单个线程进行收集。是 JDK 1.3.1 之前唯一的选择，而且目前是 Client 模式下默认收集器，可通过参数 <code>-XX:+UseSerialGC</code> 指定Serial + Serial Old组合，通过 <code>-XX:ParallelGCThreads</code> 限制垃圾收集线程数，默认为 CPU 数。</p><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p><img src="/2019/09/17/Java/Java 垃圾收集器/ParNew 收集器.png" alt="ParNew 收集器"></p><p>Serial 收集器的多线程版本，暂停所有工作线程（Stop The World）后使用多个线程进行收集，其余全部与 Serial 收集器一样。目前是 Server 模式下首选新生代收集器，并且除了 Serial 收集器外，目前只有 ParNew 收集器能与老年代 CMS 收集器配合工作。可通过参数 <code>-XX:+UseParNewGC</code>指定。</p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><img src="/2019/09/17/Java/Java 垃圾收集器/Serial Old 收集器.png" alt="Serial Old 收集器"></p><p>Serial 收集器老年代版本，使用标记 - 整理算法。主要是 client 模式下使用。</p><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>使用复制算法的新生代并行多线程收集器。主要目标是达到一个可控制的吞吐量（Throughput）。该收集器提供了两个参数精确控制吞吐量，通过 <code>-XX:MaxGCPauseMillis</code> 参数控制最大垃圾收集停顿时间以及通过 <code>-XX:GCTimeRatio</code> 参数控制吞吐量。</p><ul><li><p>MaxGCPauseMillis 参数是一个大于 0 的毫秒数，收集器尽可能满足不超过该GC 最大停顿时间。该值越小，新生代空间越小，垃圾回收也更频繁，吞吐量就越小。</p></li><li><p>GCTimeRatio 参数是一个大于 0 且小于 100 的整数，它是用户代码允许时间与垃圾回收时间的比值，默认值是 99。</p></li></ul><p>Parallel Scavenge 还提供了一个 GC 自适应调节策略参数 <code>-XX:+UseAdaptiveSizePolicy</code> 用于指定是否由虚拟机自动调节各个堆大小，只需手工把基本参数配置好（如 -Xmx），然后设置通过MaxGCPauseMillis 参数（关注停顿时间）和 GCTimeRatio 参数（关注吞吐量）设置优化目标。</p><p><img src="/2019/09/17/Java/Java 垃圾收集器/Parallel Old 收集器.png" alt="Parallel Old 收集器"></p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，JDK 1.6 开始提供，使用标记 - 整理算法。与 Parallel Scavenge 搭配。</p><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><img src="/2019/09/17/Java/Java 垃圾收集器/CMS 收集器.png" alt="CMS 收集器"></p><p>CMS 收集器（Concurrent Mark Sweep）是 HotSpot 虚拟机中第一款真正意义上的并发（Concurrent）收集器（JDK 1.5 发布），关注点是尽可能地缩短垃圾收集时用户线程的停顿时间。</p><p>CMS 收集垃圾的步骤分为以下几步，其中初始标记和重新标记需要 Stop The World。</p><ul><li>初始标记（CMS init mark），快速标记 GC Roots 能直接关联的对象</li><li>并发标记（CMS concurrent mark），GC Roots Tracing 过程</li><li>重新标记（CMS remark），为了修正并发标记期间变动的对象</li><li>并发清除（CMS concurrent sweep）</li><li>压缩整理，为了解决碎片问题，CMS 可通过 <code>-XX:+UseCMSCompactAtFullCollection</code> 决定是否开启压缩整理（默认开启），还可通过 <code>-XX:CMSFullGCsBeforeCompaction</code> 设置多少次不带整理压缩的 Full GC 后进行一次压缩整理（默认值是 0，每次Full GC都会压缩整理）</li></ul><p><strong>CMS 的缺点：</strong></p><ul><li>对 CPU 资源敏感，导致吞吐量降低。默认回收线程数是 （CPU 数 + 3） / 4，当 CPU 较少时，因为垃圾回收会对应用性能影响较大。</li><li>无法处理浮动垃圾（Floating Garbage），由于 CMS 和用户线程并发执行，在并发清除阶段会有新的垃圾产生，所以 CMS 必须在内存未满时（默认是 92%，通过 <code>-XX:CMSInitiatingOccupancyFraction</code> 控制 ）就开始启动。如果 CMS 执行期间内存无法满足需要，就会出现 <code>Concurrent Mode Failure</code> 失败，接着临时启用 Serial Old 收集器来重新进行 Full GC。</li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>G1（Garbage First） 是面向服务端应用的垃圾收集器，是当今收集器技术发展最前沿成果之一。G1 将 Java 堆划分为多个大小相等的Region，新生代和老生代不再物理隔离，G1 跟踪各个 Region 的回收价值和成本，后台维护一个优先列表，每次根据需要优先回收价值最大的 Region（G1 的由来）。为了避免 Region 之间的对象引用引起的全堆扫描，虚拟机通过 CardTable 把引用信息记录到 Region 的 Remembered Set 中。</p><p><strong>G1具备如下特点：</strong></p><ul><li>并行与并发，缩短 Stop The World</li><li>分代收集，虽然可独立管理整个 Java 堆，但是能够采用不同方式处理不同年龄的对象</li><li>空间整合，基于 Region 的标记 - 复制算法实现，不会产生内存碎片</li><li>可预测的停顿：相比 CMS 可指定某段时间内不超过多少时间的垃圾收集时间。</li></ul><p><strong>G1大致步骤如下：</strong></p><ul><li>初始标记（Initial Marking）<br>仅标记 GC Roots 直接关联的对象，并修改 TAMS 值，让下一阶段用户线程并发运行时能再正确的 Region 中创建新的对象。需要短暂的 Stop The World。</li><li>并发标记（Concurrent Marking）<br>并发从 GC Roots 开始作可达性分析，将变动记录到 Remembered Set Logs 里面。</li><li>最终标记（Final Marking）<br>修正“并发标记”阶段变化的对象，从Remembered Set Logs合并，可并行Stop The World</li><li>筛选标记（Live Data COunting and Evacuation）<br>首先对各个 Region 的回收价值和成本进行排序，根据要求制定回收计划，并行Stop The World</li></ul><h2 id="参数总结"><a href="#参数总结" class="headerlink" title="参数总结"></a>参数总结</h2><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>UseSerialGC</td><td>Serial + Serial Old 组合， 虚拟机运行于 Client 模式下的默认值</td></tr><tr><td>UseParNewGC</td><td>ParNew + Serial Old 组合</td></tr><tr><td>UseConcMarkSweepGC</td><td>ParNew + CMS + Serial Old（备用）</td></tr><tr><td>UseParallelGC</td><td>Parallel Scavenge + Serial Old 组合</td></tr><tr><td>UseParallelOldGC</td><td>Parallel Scavenge + Parallel Old 组合</td></tr><tr><td></td><td></td></tr><tr><td>SurvivorRatio</td><td>新生代中 Eden 区域与单个 Survivor 区容量比，默认为 8</td></tr><tr><td>PretenureSizeThreshold</td><td>直接晋升到老年代的对象大小，只对 Serial 和 ParNew 有效</td></tr><tr><td>MaxTenuringThreshold</td><td>晋升到老年代的对象年龄</td></tr><tr><td>UseAdaptiveSizePolicy</td><td>是否动态调整 Java 堆各个大小，默认是</td></tr><tr><td>HandlePromotionFailure</td><td>CMS 中是否允许老年代分配担保失败</td></tr><tr><td>ParallelGCThreads</td><td>设置并行 GC 时进行垃圾回收的线程数，默认为 CPU 数</td></tr><tr><td>GCTimeRatio</td><td>用户代码允许时间与垃圾回收时间的比值，仅在使用 Parallel Scavenge 有效，默认值是 99</td></tr><tr><td>MaxGCPauseMillis</td><td>GC最大停顿时间，仅在使用 Parallel Scavenge 有效</td></tr><tr><td>CMSInitiatingOccupancyFraction</td><td>CMS 在老年代在使用多少空间后出发垃圾收集器，默认 92%</td></tr><tr><td>UseCMSCompactAtFullCollection</td><td>设置是否开启，默认开启</td></tr><tr><td>CMSFullGCsBeforeCompaction</td><td>设置多少次不带整理压缩的 Full GC 后进行一次压缩整理（默认值是 0，每次Full GC都会压缩整理）</td></tr><tr><td>DisableExplicitGC</td><td>禁止 System.gc()</td></tr><tr><td>-verbose:gc</td><td>打印 GC 详情日志（稳定参数）</td></tr><tr><td>PrintGCDetails</td><td>打印 GC 详情日志（不稳定参数）</td></tr><tr><td>PrintGCDateStamps</td><td>打印日期格式的时间</td></tr><tr><td>PrintGCTimeStamps</td><td>打印时间戳格式的时间（以虚拟机启动时间为基准时间）</td></tr><tr><td>PrintHeapAtGC</td><td>GC前后打印堆信息</td></tr><tr><td>HeapDumpOnOutOfMemoryError</td><td>虚拟机出现异常时自动生成 dump 文件</td></tr><tr><td>-Xloggc:/log/file/path</td><td>日志文件的输出路径</td></tr></tbody></table></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾收集器 </tag>
            
            <tag> jvm 垃圾收集算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 命令行工具</title>
      <link href="/2019/09/16/Java/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/09/16/Java/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-命令行工具"><a href="#Java-命令行工具" class="headerlink" title="Java 命令行工具"></a>Java 命令行工具</h1><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:left">主要作用</th></tr></thead><tbody><tr><td style="text-align:center">jps</td><td style="text-align:left">JVM Process Status Tool, 显示指定系统内所有的 HotSpot 虚拟机进程</td></tr><tr><td style="text-align:center">jstat</td><td style="text-align:left">JVM Statictics Monitoring Tool, 用于收集 HotSpot 虚拟机各方面的运行数据</td></tr><tr><td style="text-align:center">jinfo</td><td style="text-align:left">JVM Configuration Info for Java, 显示虚拟机配置信息</td></tr><tr><td style="text-align:center">jmap</td><td style="text-align:left">JVM Memory Map for Java, 生成虚拟机的内存转储快照（headdump 文件）</td></tr><tr><td style="text-align:center">jhat</td><td style="text-align:left">JVM Heap Dump Brower, 用于分析 headdump 文件</td></tr><tr><td style="text-align:center">jstack</td><td style="text-align:left">JVM Stack Trace，显示虚拟机的线程快照</td></tr></tbody></table></div><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>虚拟机进程状况工具，显示虚拟机执行主类名称以及本地虚拟机唯一 ID（Local Virtual Machine Identifier，LVMID）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:center">-q</td><td>只输出 LVMID，省去主类名称</td></tr><tr><td style="text-align:center">-m</td><td>输出虚拟机进程启动时传递给主类 main() 函数的参数</td></tr><tr><td style="text-align:center">-l</td><td>输出主类全称，如果进程执行的是 jar 包则输出 jar 路径</td></tr><tr><td style="text-align:center">-v</td><td>输出虚拟机进程启动时 JVM 参数</td></tr></tbody></table></div><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>虚拟机统计信息监视工具，可以显示本地或者远程虚拟机进行中的类装载、内存、垃圾收集、JIT 编译等运行数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jstat option vmid [interval [s|ms] [count]]</span><br><span class="line"><span class="meta">#</span> 在本机 vmid=lvmid；</span><br><span class="line"><span class="meta">#</span> 远程虚拟机vmid格式为 [protocol:][//]lvmid[@hostname[:port]/servername]</span><br><span class="line"><span class="meta">#</span> interval： 间隔时间，单位为秒或者毫秒</span><br><span class="line"><span class="meta">#</span> count： 打印次数，缺省打印无数次</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:center">-class</td><td>显示类装载、卸载数量、总空间以及类装载所耗费时间等 Class Loader 的行为统计</td></tr><tr><td style="text-align:center">-compiler</td><td>显示 HotSpot JIT 编译器编译过的方法、耗时等行为统计</td></tr><tr><td style="text-align:center">-gc</td><td>显示 Java 堆各区域容量、已用空间、GC 时间等垃圾回收堆的行为统计</td></tr><tr><td style="text-align:center">-gccapacity</td><td>同-gc，主要关注 Java 堆各区域使用到的最大、最小空间</td></tr><tr><td style="text-align:center">-gcutil</td><td>同-gc，主要关注各区域已使用空间的百分比</td></tr><tr><td style="text-align:center">-gccause</td><td>同-gcutil，附加最近两次 GC 的原因</td></tr><tr><td style="text-align:center">-gcnew</td><td>显示新生代 GC 行为统计</td></tr><tr><td style="text-align:center">-gcnewcapacity</td><td>同-gcnew，主要关注新生代使用到的最大、最小空间</td></tr><tr><td style="text-align:center">-gcold</td><td>显示老年代 GC 状况</td></tr><tr><td style="text-align:center">-gcoldcapacity</td><td>同-gcold，主要关注老年代使用到的最大、最小空间</td></tr><tr><td style="text-align:center">-gcpermcapacity</td><td>输出永久代使用的最大、最小空间，JDK8 已废弃永久代</td></tr><tr><td style="text-align:center">-gcmetacapacity</td><td>输出元空间使用的最大、最小空间</td></tr><tr><td style="text-align:center">-printcompilation</td><td>输出已被 HotSpot JIT 编译的方法统计</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> jstat -class 26786</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time</span><br><span class="line"> 19680 36697.1     1579  2415.9      11.17</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Loaded：加载 class 的数量</span><br><span class="line"><span class="meta">#</span> Bytes：class 字节大小</span><br><span class="line"><span class="meta">#</span> Unloaded：未加载 class 的数量</span><br><span class="line"><span class="meta">#</span> Bytes：未加载 class 的字节大小</span><br><span class="line"><span class="meta">#</span> Time：加载时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> jstat -compiler 26786</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">   30814      7       0   174.69          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Compiled：编译数量</span><br><span class="line"><span class="meta">#</span> Failed：编译失败数量</span><br><span class="line"><span class="meta">#</span> Invalid：无效数量</span><br><span class="line"><span class="meta">#</span> Time：编译耗时</span><br><span class="line"><span class="meta">#</span> FailedType：失败类型</span><br><span class="line"><span class="meta">#</span> FailedMethod：失败方法的全限定名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> jstat -gc 26786</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">92160.0 1024.0  0.0   576.0  1397760.0 360105.2 4718592.0  3751026.1  115968.0 110124.8 13312.0 12362.1  55927 1663.225  301   135.948 1799.173</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 单位均为 KB</span><br><span class="line"><span class="meta">#</span> S0C：Survivor0区当前容量</span><br><span class="line"><span class="meta">#</span> S1C：Survivor1区当前容量</span><br><span class="line"><span class="meta">#</span> S0U：Survivor0区已使用的容量</span><br><span class="line"><span class="meta">#</span> S1U：Survivor1区已使用的容量</span><br><span class="line"><span class="meta">#</span> EC：Eden区当前容量</span><br><span class="line"><span class="meta">#</span> EU：Eden区已使用的容量</span><br><span class="line"><span class="meta">#</span> OC：Old区当前容量</span><br><span class="line"><span class="meta">#</span> OU：Old区已使用的容量</span><br><span class="line"><span class="meta">#</span> MC：当前元空间区当前容量</span><br><span class="line"><span class="meta">#</span> MU：元空间区使用的容量</span><br><span class="line"><span class="meta">#</span> CCSC：压缩类区总容量</span><br><span class="line"><span class="meta">#</span> CCSU：压缩类区使用的容量</span><br><span class="line"><span class="meta">#</span> YGC：新生代垃圾回收次数</span><br><span class="line"><span class="meta">#</span> YGCT：新生代垃圾回收时间</span><br><span class="line"><span class="meta">#</span> FGC：垃圾完全回收次数</span><br><span class="line"><span class="meta">#</span> FGCT：垃圾完全回收时间</span><br><span class="line"><span class="meta">#</span> GCT：垃圾回收总消耗时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> jstat -gccapacity 26786</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC</span><br><span class="line">1572864.0 1572864.0 1572864.0 92160.0 1024.0 1397760.0  4718592.0  4718592.0  4718592.0  4718592.0      0.0 1153024.0 115968.0      0.0 1048576.0  13312.0  55927   301</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 单位均为 KB</span><br><span class="line"><span class="meta">#</span> NGCMN：新生代最小容量</span><br><span class="line"><span class="meta">#</span> NGCMX：新生代最大容量</span><br><span class="line"><span class="meta">#</span> NGC：新生代当前空间</span><br><span class="line"><span class="meta">#</span> S0C：Survivor0区当前容量</span><br><span class="line"><span class="meta">#</span> S1C：Survivor1区当前容量</span><br><span class="line"><span class="meta">#</span> EC：Eden区当前容量</span><br><span class="line"><span class="meta">#</span> OGCMN：老年代最小容量</span><br><span class="line"><span class="meta">#</span> OGCMX：老年代最大容量</span><br><span class="line"><span class="meta">#</span> OGC：当前老年代的容量</span><br><span class="line"><span class="meta">#</span> OC：当前年老代的容量</span><br><span class="line"><span class="meta">#</span> MCMN：元空间最小容量</span><br><span class="line"><span class="meta">#</span> MCMX：元空间最大容量</span><br><span class="line"><span class="meta">#</span> MC：元空间当前容量</span><br><span class="line"><span class="meta">#</span> CCSMN：压缩类最小容量</span><br><span class="line"><span class="meta">#</span> CCSMX：压缩类最大容量</span><br><span class="line"><span class="meta">#</span> CCSC：压缩类当前容量</span><br><span class="line"><span class="meta">#</span> YGC：新生代垃圾回收次数</span><br><span class="line"><span class="meta">#</span> FGC：垃圾完全回收次数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> jstat -gcutil 26786</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00  56.25  25.76  79.49  94.96  92.86  55927 1663.225   301  135.948 1799.173</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> S0: Survivor0 已使用百分比</span><br><span class="line"><span class="meta">#</span> S1: Survivor1 已使用百分比</span><br><span class="line"><span class="meta">#</span> E: Eden区已使用百分比</span><br><span class="line"><span class="meta">#</span> O: Old区已使用百分比</span><br><span class="line"><span class="meta">#</span> M: 元空间 已使用百分比</span><br><span class="line"><span class="meta">#</span> CCS: 压缩类区已使用百分比</span><br><span class="line"><span class="meta">#</span> YGC: 新生代垃圾回收次数</span><br><span class="line"><span class="meta">#</span> YGCT: 新生代垃圾回收时间</span><br><span class="line"><span class="meta">#</span> FGC:  老年代回收次数</span><br><span class="line"><span class="meta">#</span> FGCT: 老年代回收时间</span><br><span class="line"><span class="meta">#</span> GCT: 垃圾回收总时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> jstat -gccause 26786</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC</span><br><span class="line">  0.00  56.25  25.76  79.49  94.96  92.86  55927 1663.225   301  135.948 1799.173 Allocation Failure   No GC</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 同-gcutil，附加最近两次垃圾回收事件的原因</span><br><span class="line"><span class="meta">#</span> LGCC: 上次垃圾回收的原因</span><br><span class="line"><span class="meta">#</span> GCC: 当前垃圾回收的原因</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> jstat -gcnew 26786</span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line">92160.0 1024.0    0.0  576.0  1  15 92160.0 1397760.0 360105.2  55927 1663.225</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> S0C：Survivor0区当前容量</span><br><span class="line"><span class="meta">#</span> S1C：Survivor1区当前容量</span><br><span class="line"><span class="meta">#</span> S0U：Survivor0区已使用的容量</span><br><span class="line"><span class="meta">#</span> S1U：Survivor1区已使用的容量</span><br><span class="line"><span class="meta">#</span> TT：Tenuring threshold(提升到老年代阈值)</span><br><span class="line"><span class="meta">#</span> MTT：最大的tenuring threshold</span><br><span class="line"><span class="meta">#</span> DSS：Survivor区域大小</span><br><span class="line"><span class="meta">#</span> EC：Eden区当前容量</span><br><span class="line"><span class="meta">#</span> EU：Eden区已使用的容量</span><br><span class="line"><span class="meta">#</span> YGC：新生代垃圾回收次数</span><br><span class="line"><span class="meta">#</span> YGCT：新生代垃圾回收时间</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> jstat -gcnewcapacity 26786</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC</span><br><span class="line"> 1572864.0  1572864.0  1572864.0 524288.0  92160.0 524288.0   1024.0  1571840.0  1397760.0 55927   301</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 单位均为 KB</span><br><span class="line"><span class="meta">#</span> NGCMN：新生代最小容量</span><br><span class="line"><span class="meta">#</span> NGCMX：新生代最大容量</span><br><span class="line"><span class="meta">#</span> NGC：新生代当前空间</span><br><span class="line"><span class="meta">#</span> S0CMX：Survivor0最大容量</span><br><span class="line"><span class="meta">#</span> S0C：Survivor0当前容量</span><br><span class="line"><span class="meta">#</span> S1CMX：Survivor1最大容量</span><br><span class="line"><span class="meta">#</span> S1C：Survivor1当前容量</span><br><span class="line"><span class="meta">#</span> ECMX：Eden区最大容量</span><br><span class="line"><span class="meta">#</span> EC：Eden区当前容量</span><br><span class="line"><span class="meta">#</span> YGC：新生代垃圾回收次数</span><br><span class="line"><span class="meta">#</span> YGCT：新生代垃圾回收时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> jstat -gcold 26786</span><br><span class="line">   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT</span><br><span class="line">115968.0 110124.8  13312.0  12362.1   4718592.0   3751026.1  55927   301  135.948 1799.173</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 单位均为 KB</span><br><span class="line"><span class="meta">#</span> MC: 元空间区总容量</span><br><span class="line"><span class="meta">#</span> MU: 元空间区使用容量</span><br><span class="line"><span class="meta">#</span> CCSC: 压缩类区总容量</span><br><span class="line"><span class="meta">#</span> CCSU: 压缩类区使用容量</span><br><span class="line"><span class="meta">#</span> OC: Current old space capacity (kB).</span><br><span class="line"><span class="meta">#</span> OU: Old space utilization (kB).</span><br><span class="line"><span class="meta">#</span> YGC: 新生代垃圾回收次数</span><br><span class="line"><span class="meta">#</span> FGC: 完全垃圾回收次数</span><br><span class="line"><span class="meta">#</span> FGCT: 完全垃圾回收时间</span><br><span class="line"><span class="meta">#</span> GCT: 垃圾回收总时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> jstat -gcoldcapacity 26786</span><br><span class="line">   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</span><br><span class="line">  4718592.0   4718592.0   4718592.0   4718592.0 55927   301  135.948 1799.173</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 单位均为 KB</span><br><span class="line"><span class="meta">#</span> OGCMN：老年代最小容量</span><br><span class="line"><span class="meta">#</span> OGCMX：老年代最大容量</span><br><span class="line"><span class="meta">#</span> OGC: 老年代当前容量</span><br><span class="line"><span class="meta">#</span> OC: 老年代容量</span><br><span class="line"><span class="meta">#</span> YGC: 新生代垃圾回收次数</span><br><span class="line"><span class="meta">#</span> FGC: 完全垃圾回收次数</span><br><span class="line"><span class="meta">#</span> FGCT: 完全垃圾回收时间</span><br><span class="line"><span class="meta">#</span> GCT: 垃圾回收总时间</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> jstat -printcompilation 26786</span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">   30814    580    1 com/pintec/starfleet/aerie/service/impl/ChStatOverdueServiceImpl$$Lambda$742 accept</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Compiled：被执行的编译任务的数量</span><br><span class="line"><span class="meta">#</span> Size：方法字节码的字节数</span><br><span class="line"><span class="meta">#</span> Type：编译类型</span><br><span class="line"><span class="meta">#</span> Method：编译方法的类名和方法名。类名使用"/" 代替 "." 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> jstat -gcmetacapacity 26786</span><br><span class="line">   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT</span><br><span class="line">       0.0  1153024.0   115968.0        0.0  1048576.0    13312.0 55927   301  135.948 1799.173</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 单位均为 KB</span><br><span class="line"><span class="meta">#</span> MCMN: 元空间最小容量</span><br><span class="line"><span class="meta">#</span> MCMX: 元空间最大容量</span><br><span class="line"><span class="meta">#</span> MC: 元空间容量</span><br><span class="line"><span class="meta">#</span> CCSMN: 压缩类区最小容量</span><br><span class="line"><span class="meta">#</span> CCSMX: 压缩类区最大容量</span><br><span class="line"><span class="meta">#</span> YGC: 新生代垃圾回收次数</span><br><span class="line"><span class="meta">#</span> FGC: 完全垃圾回收次数</span><br><span class="line"><span class="meta">#</span> FGCT: 完全垃圾回收时间</span><br><span class="line"><span class="meta">#</span> GCT: 垃圾回收总时间</span><br></pre></td></tr></table></figure><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>Java 配置信息工具，实时查看和调整虚拟机各项参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jinfo [ option ] pid</span><br><span class="line"></span><br><span class="line">jps -v &lt;vmid&gt; 只能查看显示指定的参数</span><br><span class="line">java -XX:+PrintFlagsFinal -version  查看所有参数值</span><br><span class="line"><span class="meta">#</span> = 表示默认值， := 表示被赋值覆盖过</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看赋值参数</span><br><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-flag <argname></argname></td><td>输出指定参数的值</td></tr><tr><td>-flags</td><td>输出显示指定的参数与值和系统属性</td></tr><tr><td>-sysprops</td><td>输出系统属性，同 System.getProperties()</td></tr><tr><td>-flag [+/-] <argname></argname></td><td>启用或禁用布尔类型参数值</td></tr><tr><td>-flag <argname>=<argvalue></argvalue></argname></td><td>设置指定参数的值</td></tr></tbody></table></div><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>Java 内存映像工具，用于生成堆转储快照（一般称为 heapdump 或 dump 文件），查询 finalize 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前用哪种收集器等。</p><blockquote><p>也可通过 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 参数当虚拟机 OOM 后自动生成 dump 文件。<br>还可通过 <code>-XX+HeamDumpOnCtrlBreak</code> 参数使用 <code>Ctrl+Break</code>或者 <code>kill -3</code>生成 dump 文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [ option ] vmid</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-dump:[live,]format=b,file=filename</td><td>生成 Java 堆转储快照文件，live 参数决定是否只 dump 存活对象</td></tr><tr><td>-finalizerinfo</td><td>显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象</td></tr><tr><td>-heap</td><td>显示 Java 堆详细信息，哪种回收器、参数配置、分代状况等信息</td></tr><tr><td>-histo[:live]</td><td>显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td>-clstats</td><td>显示class loader 统计信息</td></tr><tr><td>-F</td><td>在 dump 模式无响应时强制导出</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=/tmp/demo.hprof 26786</span><br><span class="line">Dumping heap to /tmp/demo.hprof ...</span><br><span class="line">Heap dump file created</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jmap -finalizerinfo 26786</span><br><span class="line">Attaching to process ID 26786, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.60-b23</span><br><span class="line">Number of objects pending for finalization: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jmap -histo 26786 | more</span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:      12999369     1978507048  [C</span><br><span class="line">   2:      30441816      730603584  java.lang.String</span><br><span class="line">   3:       9971651      398866040  java.math.BigDecimal</span><br><span class="line">   4:       5112071      122689704  java.util.Date</span><br><span class="line">   5:       4108426       98602224  java.lang.Long</span><br><span class="line">   6:        159773       96862744  [B</span><br><span class="line">   7:        442564       90399696  [I</span><br><span class="line">   8:       3229106       77498544  java.time.LocalDateTime</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> B - byte</span><br><span class="line"><span class="meta">#</span> C - char</span><br><span class="line"><span class="meta">#</span> D - double</span><br><span class="line"><span class="meta">#</span> F - float</span><br><span class="line"><span class="meta">#</span> I - int</span><br><span class="line"><span class="meta">#</span> J - long</span><br><span class="line"><span class="meta">#</span> Z - boolean</span><br><span class="line"><span class="meta">#</span> [ - 数组，如 [C 表示 char[]</span><br><span class="line"><span class="meta">#</span> [L+&lt;className&gt; - 其他对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jmap -heap 26786</span><br><span class="line">Attaching to process ID 26786, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.60-b23</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 8 thread(s) # 8线程并行GC</span><br><span class="line"></span><br><span class="line">Heap Configuration:                                   # 堆配置</span><br><span class="line">   MinHeapFreeRatio         = 0                       # 堆最小空闲比率</span><br><span class="line">   MaxHeapFreeRatio         = 100                     # 堆最大空闲比率</span><br><span class="line">   MaxHeapSize              = 6442450944 (6144.0MB)   # 堆最大容量</span><br><span class="line">   NewSize                  = 1610612736 (1536.0MB)   # 新生代大小</span><br><span class="line">   MaxNewSize               = 1610612736 (1536.0MB)   # 新生代最大容量</span><br><span class="line">   OldSize                  = 4831838208 (4608.0MB)   # 老年代大小</span><br><span class="line">   NewRatio                 = 3                       # 老年代与新生代的比值</span><br><span class="line">   SurvivorRatio            = 8                       # Eden与Survivor比值</span><br><span class="line">   MetaspaceSize            = 536870912 (512.0MB)     # 元空间容量</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)   # 压缩类空间大小</span><br><span class="line">   MaxMetaspaceSize         = 1073741824 (1024.0MB)   # 元空间最大容量</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)               # G1中每个Region大小</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 1416626176 (1351.0MB)</span><br><span class="line">   used     = 697265248 (664.9639587402344MB)</span><br><span class="line">   free     = 719360928 (686.0360412597656MB)</span><br><span class="line">   49.22013018062431% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 94371840 (90.0MB)</span><br><span class="line">   used     = 1016928 (0.969818115234375MB)</span><br><span class="line">   free     = 93354912 (89.03018188476562MB)</span><br><span class="line">   1.07757568359375% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 96993280 (92.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 96993280 (92.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 4831838208 (4608.0MB)</span><br><span class="line">   used     = 3841058888 (3663.119209289551MB)</span><br><span class="line">   free     = 990779320 (944.8807907104492MB)</span><br><span class="line">   79.4947745071517% used</span><br><span class="line"></span><br><span class="line">47430 interned Strings occupying 5240320 bytes.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jmap -clstats 26786 | more</span><br><span class="line">Attaching to process ID 26786, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.60-b23</span><br><span class="line">finding class loader instances ..done.</span><br><span class="line">computing per loader stat ..done.</span><br><span class="line">please wait.. computing liveness.liveness analysis may be inaccurate ...</span><br><span class="line">class_loader  classes bytes parent_loader alive?  type</span><br><span class="line"></span><br><span class="line">&lt;bootstrap&gt; 3280  5645181   null    live  &lt;internal&gt;</span><br><span class="line">0x00000000e30cbb08  12  33283 0x00000000e1ed4800  dead  groovy/lang/GroovyClassLoader$InnerLoader@0x0000000100c4cd28</span><br><span class="line">0x00000000e3146710  11  32631 0x00000000e1ed4800  dead  groovy/lang/GroovyClassLoader$InnerLoader@0x0000000100c4cd28</span><br><span class="line">0x00000000e314fb10  12  33283 0x00000000e1ed4800  dead  groovy/lang/GroovyClassLoader$InnerLoader@0x0000000100c4cd28</span><br><span class="line">0x00000000e27ef278  1 1474  0x00000000e00170c0  dead  sun/reflect/DelegatingClassLoader@0x0000000100009df8</span><br><span class="line">0x00000000e3191f10  1 1475  0x00000000e00170c0  dead  sun/reflect/DelegatingClassLoader@0x0000000100009df8</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>虚拟机堆转储快照分析工具，用于分析 jmap 生成的堆转储快照。比较耗费内存，而且统计结果没有 MAT（Memory Analyzer Tool）直观，推荐用后者。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat [ options ] heap-dump-file</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-stack false/true</td><td>是否开启跟踪分配分配调用栈，默认 true</td></tr><tr><td>-refs false/true</td><td>是否关闭对象引用的跟踪，默认 true</td></tr><tr><td>-port port-number</td><td>设置 jhat HTTP 服务器的端口号，默认 7000</td></tr><tr><td>-exclude exclude-file</td><td>指定在可访问对象中排除的文件列表</td></tr><tr><td>-baseline exclude-file</td><td>指定基准堆转储文件列表</td></tr><tr><td>-debug <level></level></td><td>设置调试级别，0表示没有调试信息，值越大输出越多调试信息</td></tr><tr><td>-J<flag></flag></td><td>传递 flag 到 jhat 运行虚拟机。如 -J-Xmx512M</td></tr></tbody></table></div><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>Java 堆栈跟踪工具，用于生成虚拟机当前时刻的线程快照，一般称为 threaddump 文件或者 javacore 文件。JDK 1.5 后可通过 Thread.getAllStackTraces() 方法获取虚拟机中所有线程对象，可用于展示 jstack 中大部分内容。</p><p>在 java.lang.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [ options ] vmid</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当虚拟机不响应时强制输出线程堆栈</td></tr><tr><td>-l</td><td>附加锁信息</td></tr><tr><td>-m</td><td>附加 C/C++ 堆栈</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">jstack  26786 | more</span><br><span class="line">2019-09-16 16:32:53</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.60-b23 mixed mode):</span><br><span class="line"></span><br><span class="line">"main-EventThread" #1986 daemon prio=5 os_prio=0 tid=0x00007f90e0047800 nid=0x5c87 waiting on condition [0x00007f91c83e0000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x000000078f87a2c0&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">at org.apache.zookeeper.ClientCnxn$EventThread.run(ClientCnxn.java:501)</span><br><span class="line"></span><br><span class="line">"main-SendThread(slave23:2181)" #1985 daemon prio=5 os_prio=0 tid=0x00007f90e0412000 nid=0x5c86 runnable [0x00007f91c84e1000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)</span><br><span class="line">at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:79)</span><br><span class="line">at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)</span><br><span class="line">- locked &lt;0x000000078f877c50&gt; (a sun.nio.ch.Util$2)</span><br><span class="line">- locked &lt;0x000000078f877c40&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">- locked &lt;0x000000078f877b28&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line">at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)</span><br><span class="line">at org.apache.zookeeper.ClientCnxnSocketNIO.doTransport(ClientCnxnSocketNIO.java:349)</span><br><span class="line">at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1141)</span><br></pre></td></tr></table></figure><h2 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h2><p>发送诊断命令工具，且该工具没有“experimental and unsupported”标志，推荐使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jcmd [-l|-h|-help]</span><br><span class="line">jcmd pid|main-class &lt;command&gt; [option]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 相当于 jps -l</span><br><span class="line">jcmd -l</span><br></pre></td></tr></table></figure><p>command命令，选项用命令查询 <code>jcmd &lt;PID&gt; help command</code></p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th><th>选项</th></tr></thead><tbody><tr><td style="text-align:left">JFR.stop</td><td style="text-align:left">停止JFR录制</td><td></td></tr><tr><td style="text-align:left">JFR.start</td><td style="text-align:left">开始新的JFR录制</td><td></td></tr><tr><td style="text-align:left">JFR.dump</td><td style="text-align:left">将JFR记录的内容复制到文件。必须指定名称或记录ID</td><td></td></tr><tr><td style="text-align:left">JFR.check</td><td style="text-align:left">检查运行JFR记录</td><td></td></tr><tr><td style="text-align:left">VM.native_memory</td><td style="text-align:left">打印本机内存使用量</td><td></td></tr><tr><td style="text-align:left">VM.check_commercial_features</td><td style="text-align:left">显示商业功能的状态</td><td></td></tr><tr><td style="text-align:left">VM.unlock_commercial_features</td><td style="text-align:left">解锁商业功能</td><td></td></tr><tr><td style="text-align:left">ManagementAgent.stop</td><td style="text-align:left">停止远程管理代理</td><td></td></tr><tr><td style="text-align:left">ManagementAgent.start_local</td><td style="text-align:left">启动本地管理代理</td><td></td></tr><tr><td style="text-align:left">ManagementAgent.start</td><td style="text-align:left">启动远程管理代理</td><td></td></tr><tr><td style="text-align:left">GC.rotate_log</td><td style="text-align:left">强制旋转GC日志文件</td><td></td></tr><tr><td style="text-align:left">Thread.print</td><td style="text-align:left">使用stacktraces打印所有线程，相当于 jstack [-l]</td><td>-l=true, 打印锁信息</td></tr><tr><td style="text-align:left">GC.class_stats</td><td style="text-align:left">提供有关Java类元数据的统计信息，需要 <code>-XX:+UnlockDiagnosticVMOptions</code>，相当于 <code>jmap -clstats &lt;PID&gt;</code></td><td></td></tr><tr><td style="text-align:left">GC.class_histogram</td><td style="text-align:left">提供有关Java堆使用情况的统计信息，相当于 <code>jmap -histo &lt;PID&gt;</code></td><td></td></tr><tr><td style="text-align:left">GC.heap_dump</td><td style="text-align:left">生成Java堆的HPROF格式转储，相当于 <code>jmap -dump:live,format=b,file=filename.hprof &lt;PID&gt;</code></td><td>-all=false, 是否包含不可达对象</td></tr><tr><td style="text-align:left">GC.run_finalization</td><td style="text-align:left">调用java.lang.System.runFinalization()</td><td></td></tr><tr><td style="text-align:left">GC.run</td><td style="text-align:left">调用java.lang.System.gc()</td><td></td></tr><tr><td style="text-align:left">VM.uptime</td><td style="text-align:left">打印VM正常运行时间</td><td></td></tr><tr><td style="text-align:left">VM.flags</td><td style="text-align:left">打印VM标志选项及其当前值，相当于 <code>jinfo -flags &lt;PID&gt;</code></td><td></td></tr><tr><td style="text-align:left">VM.system_properties</td><td style="text-align:left">打印系统属性，相当于 <code>jinfo -sysprops &lt;PID&gt;</code></td><td></td></tr><tr><td style="text-align:left">VM.command_line</td><td style="text-align:left">打印用于启动此VM实例的命令行</td><td></td></tr><tr><td style="text-align:left">VM.version</td><td style="text-align:left">打印JVM版本信息</td><td></td></tr><tr><td style="text-align:left">help</td><td style="text-align:left">有关特定命令的更多信息，请使用“help <command>”。没有参数，这将显示可用命令的列表 ‘help all’将显示所有命令的帮助</td></tr></tbody></table></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 命令行工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 数据区域</title>
      <link href="/2019/09/15/Java/Java%20%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/09/15/Java/Java%20%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-数据区域"><a href="#Java-数据区域" class="headerlink" title="Java 数据区域"></a>Java 数据区域</h1><blockquote><p>Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p></blockquote><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="/2019/09/15/Java/Java 数据区域/运行时数据区域.png" alt="运行时数据区域"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter Regiter）是线程私有的一块较小的内存空间，在虚拟机的概念模型中用于选取下一条需要执行的指令，完成分支、循环、跳转、异常处理、线程恢复等基础功能（线程切换时需要保存位置），可以看作是当前线程所执行的字节码的行号指示器。该区域无 OOM 情况。</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈（Java Virtual Machine Stacks）是线程私有的 Java 方法执行的内存区域。每个方法在执行的同时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数、动态链接、方法出口等信息，这叫入栈；当方法执行完毕后该栈帧出栈。</p><p>局部变量表存放基本数据类型、对象引用和 returnAddress 类型。long 都 double 会占用两个局部变量空间 Slot，其余占用一个 Slot。所需内存空间在编译期间完成确定，运行期间不再改变。</p><p>当线程的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError；通过 <code>-Xss</code> 设置每个栈大小，如果动态扩展时无法申请足够的内存将抛出 OOM。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stack）与 Java 虚拟机栈类似，Java虚拟机栈为 Java 方法服务，而本地方法中为虚拟机使用到的 Native 方法服务。Sun HotSpot 将此二者合二为一。</p><h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>Java 堆（Java Heap）是 Java 虚拟机中最大的一块内存，用于存放对象实例，被所有线程共享。通过 <code>-Xms -Xmx</code> 指定大小，当无法申请到足够内存时会抛出 <code>java.lang.OutOfMemoryError: Java heap space</code>。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area，也叫 Non-Heap）也是各个线程共享贡献的内存区域，用于存储已被虚拟机加载的类信息（如类名、访问修饰符、常量池、字段描述、方法描述等）、常量、静态变量、JIT 编译后的代码等数据。当无法申请到足够内存时会抛出 OOM。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放编译期生产的各种字面量和符号引用以及类的直接引用，具备动态性，可在运行期间将新的常量存放入池中。</p><p>Class 文件定义了类的版本、字段、方法、接口、常量池等描述性信息。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，而是 NIO （New Input/Output）类中基于通道（Channel）与缓冲器（Buffer）的 I/O 方式引入用于提高性能。因为它通过 Native 函数库直接分配堆外内存，然后通过存储在 Java 堆中的 DerectByteBuffer 对象引用进行操作，避免了 Java 堆与 Native 堆来回复制数据。可通过 <code>-XX:MaxDirectMemory</code> 指定大小，如果不指定则为 Java 堆的最大值，当无法申请到足够的内存后会抛出 OOM，且在 Heap Dump 中不会看到明显的异常。</p><h2 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>Sun HotSpot 遇到一条 new 指令时，首先检查常量池中该类的符号引用已经该符号引用是否已被加载、解析和初始化，如果没有则执行类加载过程。</p><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>对象所需内存的大小在类加载完成后便可完全确定，内存分配方式取决于垃圾回收器是否带有压缩整理算法。如果有压缩整理，则采用简单的指针碰撞（Bump the Pointer）；否则就采用空闲列表（Free List）。</p><p>在指针碰撞中为了解决线程安全问题，有两种解决方案。一种是对分配内存空间的动作进行同步处理，虚拟机采用 CAS 保证原子性；另一种是在 Java 堆中为每个线程预置一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer， TLAB），每个线程都在自己的 LLAB 中分配对象内存，只有在TLAB 用完后才需要同步锁定。虚拟机是否启用 TLAB，通过 <code>-XX:+/-UseTLAB</code> 参数决定。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>内存分配完成后，虚拟机将分配的内存空间都初始化为零值（不包括对象头）。接下来将类的元信息、对象的哈希码、对象的 GC 分代年龄等信息存放在对象头（Object Header）中。</p><p>虚拟机的任务完成后，才会按照开发者的意愿进行初始化。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>HotSpot 中，对象在内存中存储的布局分为 3 部分：</p><h3 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h3><p>对象头包括两部分信息：</p><ul><li><p>Mark World<br>用于存储对象自身的运行时数据，包括HashCode、GC 分代年龄、锁状态标记、线程持有锁、偏向线程 ID，偏向时间戳等信息，因为已经超过了所能记录的最大限度，故被设计成一个非固定数据结构以便在极小的空间内存储尽量多的信息，可根据对象状态复用存储空间。在 32 位和 64 位虚拟机（未开启压缩指针）中分别为 32 位和 64 位。</p></li><li><p>类型指针<br>存储指向类的元数据的指针。因为虚拟机可通过对象的元数据确定大小，但是数组的元数据中不包含大小的数据，所有需要单独存储数组长度。</p></li></ul><p>并非所有虚拟机都在对象中存储类元信息。</p><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><p>存储对象字段内容，包括继承字段。存储顺序受虚笔记分配策略参数（FieldsAllocationStyle）和字段定义顺序影响。</p><p>HotSpot 默认分配策略为相同宽度的字段总在一起： longs/doubles, intes, shorts/chars, bytes/booleans, oop(Ordinary Object Pointers)，如果 CompactFileds 参数为 False（默认 True）则父类字段总在子类前面。</p><h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>HotSpot 自动内存管理系统要求对象大小必须是 8 自己的整数倍，因为对象头肯定满足此要求，所以当实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java 程序通过栈上的 reference 数据来操作堆上的具体对象，主流访问方式有两种：</p><ul><li>句柄访问</li></ul><p><img src="/2019/09/15/Java/Java 数据区域/句柄访问.png" alt="句柄访问"></p><p>在 Java 堆中划分出一块内存作为句柄池，reference 存储句柄地址，句柄包括对象地址和类地址。</p><ul><li>直接指针访问<blockquote><p>HotSpot 采用这种方式</p></blockquote></li></ul><p><img src="/2019/09/15/Java/Java 数据区域/直接指针访问.png" alt="直接指针访问"></p><p>reference 直接存储对象地址（Java 堆），对象中存储对象类型数据的指针（方法区）。相比句柄访问节省了一次指针定位的时间开销。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 10.14 编译openJDK 8并在 Xcode 10 中调试</title>
      <link href="/2019/09/12/Java/MacOS%2010.14%20%E7%BC%96%E8%AF%91openJDK%208%E5%B9%B6%E5%9C%A8%20Xcode%2010%20%E4%B8%AD%E8%B0%83%E8%AF%95/"/>
      <url>/2019/09/12/Java/MacOS%2010.14%20%E7%BC%96%E8%AF%91openJDK%208%E5%B9%B6%E5%9C%A8%20Xcode%2010%20%E4%B8%AD%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MacOS-10-14-编译openJDK-8并在-Xcode-10-中调试"><a href="#MacOS-10-14-编译openJDK-8并在-Xcode-10-中调试" class="headerlink" title="MacOS 10.14 编译openJDK 8并在 Xcode 10 中调试"></a>MacOS 10.14 编译openJDK 8并在 Xcode 10 中调试</h1><h2 id="物料准备"><a href="#物料准备" class="headerlink" title="物料准备"></a>物料准备</h2><ul><li><p>MacOS 10.14.6</p></li><li><p>XCode 10.6</p><blockquote><p>App Store 下载</p></blockquote></li><li><p>Command Line Tools</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></li><li><p>Ant</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ant</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.oracle.com/java/technologies/javase-java-archive-javase7-downloads.html" target="_blank" rel="noopener">JDK 1.7.0_80</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Boostrap JDK, 安装好后检查</span><br><span class="line">/usr/libexec/java_home -V</span><br></pre></td></tr></table></figure></li><li><p>安装 freeType</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install freetype</span><br></pre></td></tr></table></figure></li><li><p>编译对象 OpenJDK 8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装Mercurial</span><br><span class="line">brew install mercurial</span><br><span class="line"><span class="meta">#</span> 克隆 OpenJDK8 源码</span><br><span class="line">hg clone https://hg.openjdk.java.net/jdk8u/jdk8u/</span><br><span class="line"><span class="meta">#</span> 在 jdk8u 目录下载所有模块</span><br><span class="line">chmod u+x get_source.sh</span><br><span class="line">./get_source.sh</span><br></pre></td></tr></table></figure></li></ul><h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><ul><li><p>include path for stdlibc++ headers not found<br>原因：Xcode 10.x 中已经将 stdlibc++ 移除了，<br>解决：可从 Xcode 9 中找到<a href="MacOS 10.14 编译openJDK 8并在 Xcode 10 中调试/XCode9-stdlibc++.zip">相关文件</a>放进 Xcode 10 中。</p></li><li><p>GCC compiler is required…<br>原因：检查 GCC 版本时需要包含 <code>Free Software Foundation</code>， 现有环境不满足此条件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc --version output typically looks like</span><br><span class="line">    gcc (Ubuntu/Linaro 4.8.1-10ubuntu9) 4.8.1</span><br><span class="line">    Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">    This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure></li></ul><p>解决：编辑 <code>common/autoconf/generated-configure.sh</code> ，注释以下片段<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> test $? -ne <span class="number">0</span>; then</span><br><span class="line">  AC_MSG_NOTICE([The $COMPILER_NAME compiler (located as $COMPILER) does <span class="keyword">not</span> seem to be the required $TOOLCHAIN_TYPE compiler.])</span><br><span class="line">  AC_MSG_NOTICE([The result from running with --version was: <span class="string">"$COMPILER_VERSION"</span>])</span><br><span class="line">  AC_MSG_ERROR([A $TOOLCHAIN_TYPE compiler is required. Try setting --with-tools-dir.])</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><ul><li>Xcode 4 is required to build JDK 8<br>原因：检查 Xcode 版本必须为 4，其实 10.x 也是可以的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fail-fast: verify we&apos;re building on Xcode 4, we cannot build with Xcode 5 or later</span><br></pre></td></tr></table></figure></li></ul><p>解决：编辑 <code>common/autoconf/generated-configure.sh</code> ，注释以下片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XCODE_VERSION=`$XCODEBUILD -version | grep &apos;^Xcode &apos; | sed &apos;s/Xcode //&apos;`</span><br><span class="line">XC_VERSION_PARTS=( $&#123;XCODE_VERSION//./ &#125; )</span><br><span class="line">if test ! &quot;$&#123;XC_VERSION_PARTS[[0]]&#125;&quot; = &quot;4&quot;; then</span><br><span class="line">  AC_MSG_ERROR([Xcode 4 is required to build JDK 8, the version found was $XCODE_VERSION. Use --with-xcode-path to specify the location of Xcode 4 or make Xcode 4 active by using xcode-select.])</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><ul><li><p>invalid argument ‘-std=gnu++98’ not allowed<br>原因：新版编译器已经去掉了此选项。<br>解决：编辑 <code>common/autoconf/generated-configure.sh</code> ，注释以下片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CXXSTD_CXXFLAG=&quot;-std=gnu++98&quot;</span><br></pre></td></tr></table></figure></li><li><p>A fatal error has been detected by the Java Runtime Environment…<br><code>hotspot/src/share/vm/runtime/perfData.cpp</code> 有如下代码片段，注释 <code>delete p</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerfDataManager::destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (_all == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">// destroy already called, or initialization never happened</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; _all-&gt;length(); index++) &#123;</span><br><span class="line">    PerfData* p = _all-&gt;at(index);</span><br><span class="line">    <span class="comment">// delete p;</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">delete</span>(_all);</span><br><span class="line">  <span class="keyword">delete</span>(_sampled);</span><br><span class="line">  <span class="keyword">delete</span>(_constants);</span><br><span class="line"> </span><br><span class="line">  _all = <span class="literal">NULL</span>;</span><br><span class="line">  _sampled = <span class="literal">NULL</span>;</span><br><span class="line">  _constants = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul><li><p>设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 设定语言选项，必须设置</span><br><span class="line">export LANG=C</span><br><span class="line"><span class="meta">#</span> Mac平台，C编译器不再是GCC，是clang</span><br><span class="line">export CC=clang</span><br><span class="line"><span class="meta">#</span> 跳过clang的一些严格的语法检查，不然会将N多的警告作为Error</span><br><span class="line">export COMPILER_WARNINGS_FATAL=false</span><br><span class="line"><span class="meta">#</span> 链接时使用的参数</span><br><span class="line">export LFLAGS='-Xlinker -lstdc++'</span><br><span class="line"><span class="meta">#</span> 是否使用clang</span><br><span class="line">export USE_CLANG=true</span><br><span class="line"><span class="meta">#</span> 使用64位数据模型</span><br><span class="line">export LP64=1</span><br><span class="line"><span class="meta">#</span> 告诉编译平台是64位，不然会按32位来编译</span><br><span class="line">export ARCH_DATA_MODEL=64</span><br><span class="line"><span class="meta">#</span> 允许自动下载依赖</span><br><span class="line">export ALLOW_DOWNLOADS=true</span><br><span class="line"><span class="meta">#</span> 并行编译的线程数</span><br><span class="line">export HOTSPOT_BUILD_JOBS=4</span><br><span class="line"><span class="meta">#</span> 是否跳过与先前版本的比较</span><br><span class="line">export SKIP_COMPARE_IMAGES=true</span><br><span class="line"><span class="meta">#</span> 是否使用预编译头文件，可加快编译速度</span><br><span class="line">export USE_PRECOMPILED_HEADER=true</span><br><span class="line"><span class="meta">#</span> 是否使用增量编译</span><br><span class="line">export INCREMENTAL_BUILD=true</span><br><span class="line"><span class="meta">#</span> 编译内容</span><br><span class="line">export BUILD_LANGTOOLS=true</span><br><span class="line">export BUILD_JAXP=true</span><br><span class="line">export BUILD_JAXWS=true</span><br><span class="line">export BUILD_CORBA=true</span><br><span class="line">export BUILD_HOTSPOT=true</span><br><span class="line">export BUILD_JDK=true</span><br><span class="line"><span class="meta">#</span> 编译版本</span><br><span class="line">export SKIP_DEBUG_BUILD=true</span><br><span class="line">export SKIP_FASTDEBUG_BUILD=true</span><br><span class="line">export DEBUG_NAME=debug</span><br><span class="line"><span class="meta">#</span> 避开javaws和浏览器Java插件之类的部分的build</span><br><span class="line">export BUILD_DEPLOY=false</span><br><span class="line"><span class="meta">#</span> 是否构建安装包</span><br><span class="line">export BUILD_INSTALL=true</span><br><span class="line"><span class="meta">#</span> 加上产生调试信息时需要的 objcopy</span><br><span class="line">export OBJCOPY=objcopy</span><br><span class="line"></span><br><span class="line">unset JAVA_HOME</span><br><span class="line">unset CLASSPATH</span><br></pre></td></tr></table></figure></li><li><p>configure</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zsh ./configure \</span><br><span class="line">    --with-target-bits=64 \</span><br><span class="line">    --with-debug-level=fastdebug \</span><br><span class="line">    --enable-debug-symbols \</span><br><span class="line">--with-boot-jdk=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home \</span><br><span class="line">    ZIP_DEBUGINFO_FILES=0</span><br></pre></td></tr></table></figure></li><li><p>make</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make all CONF=fastdebug 2&gt;&amp;1 | tee build.log</span><br></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd build/macosx-x86_64-normal-server-fastdebug/jdk/bin &amp;&amp; ./java -version</span><br></pre></td></tr></table></figure></li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>在 Xcode 中新建 Command Line Tools 项目</li><li>将 jdk8u 下的所有文件加入到此项目中</li><li>删除 build 下的 target</li><li>run 中添加 Executable 为编译好的 Java，在 Arguments 中添加一个 class 路径</li><li>在 <code>hotspot/src/share/vm/prims/jni.cpp</code> 中的 <code>JNI_CreateJavaVM</code> 打上断点</li><li>出现 <code>Program received signal SIGSEGV</code> 后执行命令 <code>process handle SIGSEGV --stop=false</code></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 编译 </tag>
            
            <tag> 调试 </tag>
            
            <tag> openJDK </tag>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java概述</title>
      <link href="/2019/09/11/Java/Java%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/09/11/Java/Java%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><blockquote><p>世界上并没有完美的程序。但我们并不因此而沮丧。因为写程序本来就是一个不断追求完美的过程。</p></blockquote><p>Java提供了一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界问题；它实现了热点代码检测和运行时编译及优化；它有完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助它实现各种各样的功能……</p><h2 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h2><p>Java是目前用户最多、使用范围最广的软件开发技术之一。Java的技术体系<strong>按功能划分</strong>有:</p><blockquote><p>Java编程语言、Java虚拟机、Java API类库统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境。Java SE API（Java API子集）和Java虚拟机统称为JRE（Java Runtime ENvironment），JRE是支持Java程序运行的标准环境。</p></blockquote><ul><li>Java编程语言</li><li><p>Java虚拟机</p><blockquote><p>隐藏了底层技术的复杂性以及机器与操作系统的差异性，实现了“一次编写，到处运行”</p></blockquote></li><li><p>Class文件格式</p></li><li>Java API类库</li><li>第三方类库</li></ul><p><img src="/2019/09/11/Java/Java概述/Java8技术体系.png" alt="Java8技术体系"></p><p><img src="/2019/09/11/Java/Java概述/Java7技术体系.png" alt="Java7技术体系"></p><p>Java技术体系<strong>按服务对象</strong>划分：</p><ul><li>Java Card： 支持一些小程序（Applets）运行在小内存设备（如智能卡）上的平台。</li><li>Java ME：对Java API有所精简，支持移动终端（手机、PAD）上的平台。</li><li>Java SE：提供完整Java API，支持面向桌面级应用的平台。</li><li>Java EE：在Java SE的基础上扩充，并提供部署支持。</li></ul><h2 id="Java发展史"><a href="#Java发展史" class="headerlink" title="Java发展史"></a>Java发展史</h2><p><img src="/2019/09/11/Java/Java概述/Java发展史.png" alt="Java发展史"></p><ul><li>1991年4月，1955年5月19日出生于加拿大的 James Gosling 领导 Green Project，为了提供可供各种消费性电子产品上运行的程序架构，计划失败，但是诞生了面向对象的编程语言Oak（Java语言的前身）。</li><li>1995年5月23日，Oak语言改名为Java，并在 SunWorld 大会上正式发布Java 1.0。提出 “Write Once, Run Anywhere” 口号。</li><li>1996年1月23号，JDK1.0发布，提供了一个纯解释执行的Java虚拟机实现 Sun Classic VM、Applet、AWT等。</li><li>1996年5月，Sun在美国旧金山举行了首届 JavaOne 大会。</li><li>1997年2月19日，JDK 1.1 发布，包括JAR文件格式、JDBC、JavaBean、RMI、内部类和反射等。</li><li>1998年12月4日，JDK 1.2 发布，将Java技术体系拆分为3个方向，分别是面向桌面开发的J2SE、面向企业级开发的 J2EE和面向移动终端开发J2ME。出现了EJB、 Java Plug-in、Java IDL、Swing、Collections等技术以及首次内置了JIT（Just In Time）编译器的虚拟机（HotSpot VM 和 Exact VM）。</li><li>2000年5月8日，JDK 1.3 发布。JNDI作为平台级服务、改进 Java 2D等。</li><li>2002年2月13日，JDK 1.4 发布，同日.Net 1.0发布。优化性能问题，新增了正则表达式、异常链、NIO、日志类、XML解析器、XSLT转换器等，真正走向成熟。</li><li>2004年9月30日，JDK 1.5 发布，改进极大，故公开版更名为 JDK 5.0。改进包括自动装箱、泛型、动态注解、枚举、可变长参数、高级for循环、Java内存模型（Java Memory Model，JMM）、java.util.concurrent 并发包等。</li><li>2006年12月11日，JDK 1.6 发布，提供动态语言支持（通过内置 Mozilla JavaScript Rhino 引擎实现）、提供编译API和微型 HTTP 服务器 API 、算法（锁与同步、垃圾收集、类加载等）等改进。</li><li>2006年11月13日，Sun宣布在GPL v2（GNU General Public License v2）协议下公开了源代码，并建立了 OpenJDK 组织对这些源码进行独立管理。</li><li>2007年11月5日，Google公布基于 Java 的 Android 操作系统。</li><li>2009年4月20日，Oracle 74亿美元收购 Sun，此时 Oracle 同时拥有了三大商业虚拟机中的两个 HotSpot 和从 BEA 收购来的 JRockit。</li><li>2011年7月28日，JDK 1.7 发布，引入了二进制证书、支持字符串的 switch 语句、菱形语法、多异常捕获、自动关闭资源的 try 语句等新特性。在第4个小版本中开始支持Mac系统，并第6个版本中完全支持。</li><li>2014年3月18日，JDK 1.8 发布，带来了 Lambda 表达式，Stream API流式处理等。</li><li>2017年9月22日，JDK 1.9 发布，模块化（Jigsaw）落地。</li></ul><h2 id="Java虚拟机发展史"><a href="#Java虚拟机发展史" class="headerlink" title="Java虚拟机发展史"></a>Java虚拟机发展史</h2><ul><li><p>Sun Classic VM<br>世界上第一款商用 Java 虚拟机，纯解释器执行，或者用外挂 JIT 编译器完全替代（慢）。JDK 1.4 退出。</p></li><li><p>Sun Exact VM<br>因采用准确式内存管理（Exact Memory Management ）而得名，已具备现代高性能虚拟机的雏形，如两级即时编译器，编译器与解释器混合工作模式等。后来被 HotSpot 取代。</p></li><li><p>Sun HotSpot VM<br>由 Longview Technologies 公司开发，1997年被 Sun 收购，HotSpot拥有前两款虚拟机所有的优点，另有自己的技术优势，如热点代码探测技术等，打败了 Sun Exact VM。</p></li><li><p>Sun KVM VM<br>KVM 是 Kilobyte 的意思，强调简单、轻量、高度可移植，但是运行速度慢，在 Android、IOS 等智能手机系统出现前应用广泛。</p></li><li><p>Sun CDC/CLDC HotSpot Implementation VM<br>全称是 Connected（Limited） Device Configuration，在 JSR-139/JSR-218规范中定义，是整个 Java ME 的重要支柱，系统在手机、电子书、PAD等设备建立统一的 Java 编程接口。</p></li><li><p>Sun Squawk VM<br>运行于 Sun SPOT（Sun Small Programmable Object Technology 手持 WIFI 设备），是 Java 比重很高的嵌入式虚拟机实现，仅靠 C 语言来编写设备 I/O 和必要的本地代码。</p></li><li><p>JavaInJava<br>Sun开发的实验性虚拟机，试图以 Java 语言来实现 Java 语言本身的运行环境，速度慢。</p></li><li><p>Maxine VM<br>2005年开始，除了 JVM 的加载器使用 C 来实现，其余都用 Java 实现， 它拥有先进的 JIT 编译器和垃圾收集器（但没有解释器），可在宿主或独立模式下运行，执行效率接近 HotSpot Client VM 的水平。</p></li><li><p>BEA JRockit VM<br>曾经号称世界上最快的Java虚拟机，它是 BEA 在2002年从 Appeal Virtual Machines 收购的虚拟机，由于专注于服务器端应用不太关注程序启动速度，因为不包含解析器实现。JRockit 的垃圾收集器和 MissionControl 服务套件处于世界领先水平。</p></li><li><p>IBM J9 VM<br>J9 是IBM Ottawa 实验室一个名为 SmallTalk 虚拟机扩展而来。它市场定位与 HotSpot 接近，服务器、桌面、嵌入式设备多用途虚拟机。</p></li><li><p>Azul VM<br>Azul System 在 HotSpot 基础上进行大量改进，运行于自有专有硬件 Vega 系统上的 Java 虚拟机，每个实例可管理至少数十个 CPU 和数百 GB 内存的硬件自有，并提供在巨大内存范围内实现可控的 GC 时间的垃圾收集器、为专有硬件优化的现成调度等优秀特性。</p></li><li><p>BEA Liquid VM<br>BEA 公司开发，它自身实现了一个专用操作系统的必要功能，可最大限度发挥硬件的能力，提升 Java 程序的执行性能。</p></li><li><p>Apache Harmony<br>Apache 基金会旗下开源的兼容于 JDK 1.5 和 JDK 1.6 的 Java 程序运行平台。</p></li><li><p>Google Android Dalvik VM<br>Android平台核心组成部分之一，没有遵循 Java 虚拟机规范而使用了寄存器架构，不能直接执行 Class 文件。但是它执行的 dex 文件可以通过 Class 文件转化而来，可直接使用大部分的 Java API。</p></li><li><p>Microsoft JVM<br>当时 Windows 上性能最好的 Java 虚拟机。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 历史 </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础语法</title>
      <link href="/2019/09/08/MySQL/MySQL/"/>
      <url>/2019/09/08/MySQL/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基础语法"><a href="#MySQL基础语法" class="headerlink" title="MySQL基础语法"></a>MySQL基础语法</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>mysql官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/</a></p></blockquote><p>数据库是以一定方式储存在一起、能与多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合，用户可以对文件中的数据进行新增、查询、更新、删除等操作。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>关系型数据库：<br>MySQL、MariaDB、SQLLite、SQLServer、PostgreSQL、ORACLE</li><li>非关系型数据库：<br>MongoDB文档型、redisK—V型、列式数据库、图形数据库</li></ul><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p>要查询数据库表的数据，使用如下的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;表名&gt;：</span><br><span class="line"><span class="comment">-- 查询students表的所有数据：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students;</span><br><span class="line"><span class="comment">-- 查询classes表的所有数据：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> classes;</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">条件查询的语法就是：<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;表名&gt; <span class="keyword">WHERE</span> &lt;条件表达式&gt;，例如：</span><br><span class="line"><span class="comment">-- 按条件查询students:</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> score &gt;= <span class="number">80</span>;</span><br><span class="line"><span class="comment">-- 按OR条件查询students:</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> score &gt;= <span class="number">80</span> <span class="keyword">OR</span> gender = <span class="string">'M'</span>;</span><br><span class="line"><span class="comment">-- 按NOT条件查询students:</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">NOT</span> class_id = <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 按多个条件查询students:</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> (score &lt; <span class="number">80</span> <span class="keyword">OR</span> score &gt; <span class="number">90</span>) <span class="keyword">AND</span> gender = <span class="string">'M'</span>;</span><br><span class="line"><span class="comment">--查询分数在60分(含)～90分(含)：</span></span><br><span class="line">WHERE score &gt;= 60 AND score &lt;= 90；</span><br><span class="line">WHERE score BETWEEN 60 AND 90；</span><br></pre></td></tr></table></figure><h4 id="常用的条件表达式"><a href="#常用的条件表达式" class="headerlink" title="常用的条件表达式"></a>常用的条件表达式</h4><div class="table-container"><table><thead><tr><th style="text-align:left">条件</th><th style="text-align:left">表达式举例1</th><th style="text-align:left">表达式举例2</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">使用=判断相等</td><td style="text-align:left">score = 80</td><td style="text-align:left">name = ‘abc’</td><td style="text-align:left">字符串需要用单引号括起来</td></tr><tr><td style="text-align:left">使用&gt;判断大于</td><td style="text-align:left">score &gt; 80</td><td style="text-align:left">name &gt; ‘abc’</td><td style="text-align:left">字符串比较根据ASCII码，中文字符比较根据数据库设置</td></tr><tr><td style="text-align:left">使用&gt;=判断大于或相等</td><td style="text-align:left">score &gt;= 80</td><td style="text-align:left">name &gt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;判断小于</td><td style="text-align:left">score &lt; 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;=判断小于或相等</td><td style="text-align:left">score &lt;= 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;&gt;判断不相等</td><td style="text-align:left">score &lt;&gt; 80</td><td style="text-align:left">name &lt;&gt; ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用LIKE判断相似</td><td style="text-align:left">name LIKE ‘ab%’</td><td style="text-align:left">name LIKE ‘%bc%’</td><td style="text-align:left">%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td></tr></tbody></table></div><h3 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用<span class="keyword">SELECT</span> 列<span class="number">1</span>, 列<span class="number">2</span>, 列<span class="number">3</span> <span class="keyword">FROM</span> ...，让结果集仅包含指定列；例如：</span><br><span class="line"><span class="comment">-- 使用投影查询：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, score, <span class="keyword">name</span> <span class="keyword">FROM</span> students;</span><br><span class="line"><span class="comment">-- 使用投影查询，并将列名重命名：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, score points, <span class="keyword">name</span> <span class="keyword">FROM</span> students;</span><br><span class="line"><span class="comment">-- 使用投影查询+WHERE条件：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, score points, <span class="keyword">name</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender = <span class="string">'M'</span>;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按score从低到高：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br><span class="line"><span class="comment">-- 按score从高到低：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br><span class="line"><span class="comment">-- 按score, gender排序:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>, gender;</span><br><span class="line"><span class="comment">-- 带WHERE条件的ORDER BY:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> class_id = <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>分页实际上就是从结果集中“截取”出第M~N条记录，<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>，例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询第1页：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 查询第2页：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 查询第3页：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">LIMIT总是设定为pageSize；</span><br><span class="line">OFFSET计算公式为pageSize * (pageIndex - 1)。</span><br></pre></td></tr></table></figure><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用聚合查询:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> students;</span><br><span class="line"><span class="comment">-- 使用聚合查询并设置结果集的列名为num:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">num</span> <span class="keyword">FROM</span> students;</span><br><span class="line"><span class="comment">-- 使用聚合查询并设置WHERE条件:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) boys <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender = <span class="string">'M'</span>;</span><br><span class="line"><span class="comment">-- 使用聚合查询计算男生平均成绩:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(score) average <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender = <span class="string">'M'</span>;</span><br><span class="line">每页3条记录，如何通过聚合查询获得总页数：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEILING</span>(<span class="keyword">COUNT</span>(*) / <span class="number">3</span>) <span class="keyword">FROM</span> students;</span><br><span class="line"><span class="comment">-- 按class_id分组:</span></span><br><span class="line"><span class="keyword">SELECT</span> class_id, <span class="keyword">COUNT</span>(*) <span class="keyword">num</span> <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, class_id, <span class="keyword">COUNT</span>(*) <span class="keyword">num</span> <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br><span class="line"><span class="comment">-- 按class_id, gender分组:</span></span><br><span class="line"><span class="keyword">SELECT</span> class_id, gender, <span class="keyword">COUNT</span>(*) <span class="keyword">num</span> <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id, gender;</span><br><span class="line"><span class="comment">-- 查出每个班级的平均分：</span></span><br><span class="line"><span class="keyword">select</span> class_id,<span class="keyword">round</span>(<span class="keyword">avg</span>(score),<span class="number">2</span>) average <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br><span class="line"><span class="comment">--查出每个班级男生和女生的平均分：</span></span><br><span class="line"><span class="keyword">select</span> class_id,gender,<span class="keyword">round</span>(<span class="keyword">avg</span>(score),<span class="number">2</span>) average <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id,gender;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">SUM</td><td style="text-align:left">计算某一列的合计值，该列必须为数值类型</td></tr><tr><td style="text-align:left">AVG</td><td style="text-align:left">计算某一列的平均值，该列必须为数值类型</td></tr><tr><td style="text-align:left">MAX</td><td style="text-align:left">计算某一列的最大值</td></tr><tr><td style="text-align:left">MIN</td><td style="text-align:left">计算某一列的最小值</td></tr></tbody></table></div><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">查询多张表的语法是：<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; &lt;表<span class="number">2</span>&gt;，例如：</span><br><span class="line"><span class="comment">-- FROM students, classes:</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students, classes;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- set alias:</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    students.id <span class="keyword">sid</span>,</span><br><span class="line">    students.name,</span><br><span class="line">    students.gender,</span><br><span class="line">    students.score,</span><br><span class="line">    classes.id cid,</span><br><span class="line">    classes.name cname</span><br><span class="line"><span class="keyword">FROM</span> students, classes;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- set table alias:</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s.id <span class="keyword">sid</span>,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line"><span class="keyword">FROM</span> students s, classes c;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- set where clause:</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s.id <span class="keyword">sid</span>,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line"><span class="keyword">FROM</span> students s, classes c</span><br><span class="line"><span class="keyword">WHERE</span> s.gender = <span class="string">'M'</span> <span class="keyword">AND</span> c.id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 选出所有学生：</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, s.gender, s.score <span class="keyword">FROM</span> students s;</span><br><span class="line"><span class="comment">-- 选出所有学生，同时返回班级名称：</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id = c.id;</span><br><span class="line"><span class="comment">-- 使用OUTER JOIN：</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id = c.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先增加一列class_id=5:</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">values</span> (<span class="number">5</span>, <span class="string">'新生'</span>, <span class="string">'M'</span>, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用LEFT OUTER JOIN：</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id = c.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用FULL OUTER JOIN：</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id = c.id;</span><br></pre></td></tr></table></figure><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><h3 id="insert（插入）"><a href="#insert（插入）" class="headerlink" title="insert（插入）"></a>insert（插入）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>语句的基本语法是：<span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt; (字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);  例如：</span><br><span class="line"><span class="comment">-- 添加一条新记录：</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'大牛'</span>, <span class="string">'M'</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一次性添加多条新记录：</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">'大宝'</span>, <span class="string">'M'</span>, <span class="number">87</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'二宝'</span>, <span class="string">'M'</span>, <span class="number">81</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><h3 id="update（更新）"><a href="#update（更新）" class="headerlink" title="update（更新）"></a>update（更新）</h3><p>UPDATE语句的基本语法是：<code>UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...</code>。特别注意，UPDATE语句可以没有WHERE条件，例如：<code>UPDATE students SET score=60</code>;整个表的所有记录都会被更新，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新id=1的记录：</span></span><br><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">'大牛'</span>, score=<span class="number">66</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新id=5,6,7的记录：</span></span><br><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">'小牛'</span>, score=<span class="number">77</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>&gt;=<span class="number">5</span> <span class="keyword">AND</span> <span class="keyword">id</span>&lt;=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新score&lt;80的记录：</span></span><br><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> score=score+<span class="number">10</span> <span class="keyword">WHERE</span> score&lt;<span class="number">80</span>;</span><br></pre></td></tr></table></figure><h3 id="delete-删除"><a href="#delete-删除" class="headerlink" title="delete(删除)"></a>delete(删除)</h3><p>特别注意，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据：DELETE FROM students;在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span>语句的基本语法是：<span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;表名&gt; <span class="keyword">WHERE</span> ...;</span><br><span class="line"><span class="comment">-- 删除id=1的记录：</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除id=5,6,7的记录：</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">id</span>&gt;=<span class="number">5</span> <span class="keyword">AND</span> <span class="keyword">id</span>&lt;=<span class="number">7</span>;</span><br></pre></td></tr></table></figure><h3 id="实用SQL语句"><a href="#实用SQL语句" class="headerlink" title="实用SQL语句"></a>实用SQL语句</h3><ul><li><p>插入或替换<br>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">'小明'</span>, <span class="string">'F'</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure></li><li><p>插入或更新<br>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<br><code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">'小明'</span>, <span class="string">'F'</span>, <span class="number">99</span>) <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> <span class="keyword">name</span>=<span class="string">'小明'</span>, gender=<span class="string">'F'</span>, score=<span class="number">99</span>;</span><br></pre></td></tr></table></figure></li><li><p>插入或忽略<br>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">IGNORE</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">'小明'</span>, <span class="string">'F'</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure></li><li><p>快照<br>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students_of_class1 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> class_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>写入查询结果集<br>如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个统计成绩的表statistics，记录各班的平均成绩：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">statistics</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    class_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    average <span class="keyword">DOUBLE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 写入各班的平均成绩：</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">statistics</span> (class_id, average) <span class="keyword">SELECT</span> class_id, <span class="keyword">AVG</span>(score) <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oh My ZSH 简明安装教程</title>
      <link href="/2019/09/07/%E6%95%88%E7%8E%87/Oh-My-ZSH%E7%AE%80%E6%98%8E%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2019/09/07/%E6%95%88%E7%8E%87/Oh-My-ZSH%E7%AE%80%E6%98%8E%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Oh-My-ZSH-简明安装教程"><a href="#Oh-My-ZSH-简明安装教程" class="headerlink" title="Oh My ZSH 简明安装教程"></a>Oh My ZSH 简明安装教程</h1><blockquote><p>Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration. It comes bundled with thousands of helpful functions, helpers, plugins, themes, and a few things that make you shout…</p><p><code>Z sh</code> 中的 Z是最后一个字母，顾名思义就是最后一个shell，最好的shell。</p></blockquote><h2 id="ZSH安装"><a href="#ZSH安装" class="headerlink" title="ZSH安装"></a>ZSH安装</h2><h3 id="查看当前系统已有shell"><a href="#查看当前系统已有shell" class="headerlink" title="查看当前系统已有shell"></a>查看当前系统已有shell</h3><blockquote><p>确保已有zsh，并且版本号不小于4.3.9。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br><span class="line">zsh --version</span><br></pre></td></tr></table></figure><h3 id="如没有zsh，则安装"><a href="#如没有zsh，则安装" class="headerlink" title="如没有zsh，则安装"></a>如没有zsh，则安装</h3><ul><li><p>mac自带</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zsh</span><br></pre></td></tr></table></figure></li><li><p>CentOS 7</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zsh</span><br></pre></td></tr></table></figure></li><li><p>Ubuntu</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install zsh</span><br></pre></td></tr></table></figure></li><li><p>设置当前用户默认shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s $(which zsh)</span><br></pre></td></tr></table></figure></li></ul><h2 id="oh-my-zsh安装"><a href="#oh-my-zsh安装" class="headerlink" title="oh-my-zsh安装"></a><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a>安装</h2><ul><li>安装</li></ul><blockquote><p>需用到Git，需提前安装</p></blockquote><ul><li><p>curl方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span><br></pre></td></tr></table></figure></li><li><p>wget方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>改变主题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 这里选择简洁的ys主题，修改 ZSH_THEME="ys"</span><br><span class="line">vim ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果在mac下iterm2中导入颜色和背景 </span><br><span class="line"><span class="meta">#</span> 颜色 下载 https://github.com/bahlo/iterm-colors/blob/master/colors/Darkside.itermcolors</span><br><span class="line"><span class="meta">#</span> 背景图片 https://pan.baidu.com/s/14SpdtZIc6-kkXVJZPucQyw</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进一步简化提示符，替换ys主题的PROMPT配置</span><br><span class="line">vim ~/.oh-my-zsh/themes/ys.zsh-theme</span><br><span class="line"></span><br><span class="line">PROMPT="</span><br><span class="line"><span class="meta">%</span>&#123;$terminfo[bold]$fg[blue]%&#125;#%&#123;$reset_color%&#125; \</span><br><span class="line"><span class="meta">%</span>&#123;$terminfo[bold]$fg[yellow]%&#125;%~%&#123;$reset_color%&#125;\</span><br><span class="line"><span class="meta">$</span>&#123;hg_info&#125;\</span><br><span class="line"><span class="meta">$</span>&#123;git_info&#125;\</span><br><span class="line">\</span><br><span class="line"><span class="meta">%</span>&#123;$fg[white]%&#125;[%*] $exit_code</span><br><span class="line"><span class="meta">%</span>&#123;$terminfo[bold]$fg[red]%&#125;$ %&#123;$reset_color%&#125;"</span><br></pre></td></tr></table></figure></li><li><p>插件</p><ul><li><p>快速跳转 <a href="https://github.com/wting/autojump" target="_blank" rel="noopener">autojump</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install autojump-zsh -y</span><br></pre></td></tr></table></figure></li><li><p>智能提示 <a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md" target="_blank" rel="noopener">zsh-autosuggestions</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></li><li><p>语法高亮 <a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></li><li><p>自动完成 <a href="https://github.com/zsh-users/zsh-completions" target="_blank" rel="noopener">zsh-completions</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-completions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-completions</span><br></pre></td></tr></table></figure></li><li><p>路径补全 <a href="http://mimosa-pudica.net/zsh-incremental.html" target="_blank" rel="noopener">Incremental completion</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mimosa-pudica.net/src/incr-0.2.zsh -P $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/incr</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>配置插件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span> vim ~/.zshrc，替换plugins配置</span><br><span class="line"> plugins=(</span><br><span class="line">   git</span><br><span class="line">   mvn</span><br><span class="line">   gradle</span><br><span class="line">   zsh-autosuggestions</span><br><span class="line">   zsh-syntax-highlighting</span><br><span class="line">   zsh-completions</span><br><span class="line">   autojump</span><br><span class="line"> )</span><br><span class="line">source ~/.oh-my-zsh/custom/plugins/incr/incr-0.2.zsh</span><br><span class="line"> source ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>重建完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f ~/.zcompdump;autoload -U compinit &amp;&amp; compinit</span><br></pre></td></tr></table></figure></li></ul><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>Oh My ZSH 安装完成后文件与目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.zshrc #配置文件</span><br><span class="line">.zsh_history # 历史命令</span><br><span class="line">.oh-my-zsh/</span><br><span class="line">├── custom #自定义主题扩展等</span><br><span class="line">├── oh-my-zsh.sh</span><br><span class="line">├── plugins # 自带插件</span><br><span class="line">├── templates </span><br><span class="line">├── themes # 自带主题</span><br><span class="line">└── tools</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> zsh </tag>
            
            <tag> Oh My ZSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows效率工具</title>
      <link href="/2019/01/19/%E6%95%88%E7%8E%87/windows%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/01/19/%E6%95%88%E7%8E%87/windows%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="windows-键位"><a href="#windows-键位" class="headerlink" title="windows 键位"></a>windows 键位</h2><p>同时使用过windows和mac后，会发现mac的控制键位要比windows合理得多。故在此记录将windows的控制键位向mac看齐的方法。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>将 <code>Caps Lock</code> 都映射到 <code>Ctrl</code></li><li>将左边的 <code>Alt</code>映射到 <code>Ctrl</code></li><li>将左边的 <code>Ctrl</code> 映射到 <code>Windows</code></li><li>将 ‘Windows’ 键映射到左边的 <code>Alt</code></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="SharpKeys"><a href="#SharpKeys" class="headerlink" title="SharpKeys"></a><a href="https://github.com/randyrants/sharpkeys/releases" target="_blank" rel="noopener">SharpKeys</a></h4><ul><li>下载此工具并安装</li><li>设置映射键位</li><li>写入到注册表</li><li>重启</li></ul><p><img src="/2019/01/19/效率/windows效率工具/sharp-key-label.png" alt="sharp-key-label"></p><ul><li>或者直接使用bat脚本</li></ul><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version <span class="number">5</span>.<span class="number">00</span> </span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]</span><br><span class="line">"Scancode Map"=hex:<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">05</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">1</span>D,<span class="number">00</span>,<span class="number">3</span>A,<span class="number">00</span>,<span class="number">1</span>D,<span class="number">00</span>,<span class="number">38</span>,<span class="number">00</span>,<span class="number">5</span>B,E0,<span class="number">1</span>D,<span class="number">00</span>,<span class="number">38</span>,<span class="number">00</span>,<span class="number">5</span>B,E0,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span></span><br></pre></td></tr></table></figure><h4 id="AutoHotkey"><a href="#AutoHotkey" class="headerlink" title="AutoHotkey"></a><a href="https://github.com/Lexikos/AutoHotkey_L/releases" target="_blank" rel="noopener">AutoHotkey</a></h4><blockquote><p>通过上述改键后，Alt变成了Ctrl，窗口切换（Alt+Tab）就会很难受了， 可使用该工具将 Alt + Tab 映射到真实的 Alt + Tab 完成窗口切换</p></blockquote><ul><li>下载并安装</li><li>新建脚本文件 <code>hotKey.ahk</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LControl &amp; Tab::AltTab</span><br></pre></td></tr></table></figure><ul><li>双击运行</li><li>开机自动运行脚本，将脚本放入文件夹 <code>%programdata%\Microsoft\Windows\Start Menu\Programs\Startup</code>。在任务管理器的启动标签栏中也可看到。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> 效率 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Markdown写高大上的幻灯片</title>
      <link href="/2019/01/14/reveal/%E4%BD%BF%E7%94%A8Markdown%E5%86%99%E9%AB%98%E5%A4%A7%E4%B8%8A%E7%9A%84PPT/"/>
      <url>/2019/01/14/reveal/%E4%BD%BF%E7%94%A8Markdown%E5%86%99%E9%AB%98%E5%A4%A7%E4%B8%8A%E7%9A%84PPT/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><!-- .slide: data-background="#49B1F5" --><p>很多时候，做一些简单的演示并不需要 PPT 或者 keynote 这样重量级的软件，使用 reveal.js 即可将 Markdown 转为绚丽的 HTML5 形式的幻灯片。</p><blockquote><p>查看文档 <a href="https://github.com/hakimel/reveal.js#markdown" target="_blank" rel="noopener">reveal</a></p></blockquote><p>===</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><!-- .slide: data-transition="concave" data-background="#C7916B" --><h3 id="新建幻灯片markdown文件"><a href="#新建幻灯片markdown文件" class="headerlink" title="新建幻灯片markdown文件"></a>新建幻灯片markdown文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new slide 使用Markdown写高大上的幻灯片</span><br></pre></td></tr></table></figure><ul><li>会自动创建具有以下内容的文件</li><li>也可手动创建包含此内容的文件 <!-- .element: class="fragment" data-fragment-index="1" --></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">使用Markdown写高大上的幻灯片</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">slides</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Markdown</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PPT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">幻灯片</span></span><br><span class="line"><span class="attr">slide:</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">sky</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="number">-01</span><span class="number">-14</span> <span class="number">22</span><span class="string">:37:44</span></span><br></pre></td></tr></table></figure><p>==</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><!-- .slide: data-transition="concave" data-background="#C7916B" --><ul><li><p>根据具体情况创建文件夹，此文件夹名称为该文件所属分类。</p></li><li><p>然后将md文件和相应的资源文件夹挪到上述创建的文件夹中。</p></li></ul><p>===</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><!-- .slide: data-transition="fade" data-background="#00C4B6" --><ul><li>black：黑色背景，白色文字，蓝色链接（默认）</li><li>white：白色背景，黑色文字，蓝色链接</li><li>league：灰色背景，白色文本，蓝色链接</li><li>beige：米色背景，深色文字，棕色链接</li><li>sky：蓝色背景，细细的深色文字，蓝色链接</li><li>night：黑色背景，厚厚的白色文字，橙色链接</li><li>serifrif：卡布奇诺背景，灰色文本，棕色链接</li><li>simple：白色背景，黑色文字，蓝色链接</li><li>solarized：奶油色背景，深绿色文字，蓝色链接</li></ul><p>===</p><h2 id="幻灯片页面"><a href="#幻灯片页面" class="headerlink" title="幻灯片页面"></a>幻灯片页面</h2><!-- .slide: data-transition="fade" data-background="#00C4B6" --><ul><li>若下一个页面是子页面则使用 <code>= =</code> 隔开 </li><li>若是并列页面则使用 <code>= = =</code> 隔开</li><li>使用 markdown 语法编写标题 <!-- .element: class="fragment" data-fragment-index="1" --></li><li>在标题下一行使用特殊语法 <!-- .element: class="fragment" data-fragment-index="2" --></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- .slide: data-transition=&quot;fade&quot; data-background=&quot;#00C4B6&quot; data-autoslide=&quot;2000&quot; --&gt;</span><br></pre></td></tr></table></figure><p>== </p><h3 id="data-background"><a href="#data-background" class="headerlink" title="data-background"></a>data-background</h3><!-- .slide: data-transition="zoom" data-background="#F47466" --><p>此属性设置当前幻灯片的背景颜色</p><p>== </p><h3 id="data-transition"><a href="#data-transition" class="headerlink" title="data-transition"></a>data-transition</h3><!-- .slide: data-transition="convex" data-background="#69C282" --><p>此属性设置当前幻灯片的动画</p><p>==</p><h3 id="data-autoslide"><a href="#data-autoslide" class="headerlink" title="data-autoslide"></a>data-autoslide</h3><p>此属性设置自动播放下一页的延迟时间， 单位:毫秒</p>]]></content>
      
      
      <categories>
          
          <category> reveal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> PPT </tag>
            
            <tag> 幻灯片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo从零开始</title>
      <link href="/2019/01/09/Hexo/Hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"/>
      <url>/2019/01/09/Hexo/Hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo从零开始"><a href="#Hexo从零开始" class="headerlink" title="Hexo从零开始"></a>Hexo从零开始</h1><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。</p></blockquote><h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p><a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">Hexo</a> 是基于 Node 开发的非常流行的开源博客系统，故天生具有跨平台特性；使用 Markdown（或其他渲染引擎）解析文章，支持 GitHub Flavored Markdown 的所有功能；拥有强大的插件系统，可支持 Jade, CoffeeScript，甚至可以整合 Octopress 的大多数插件。</p><h2 id="Hexo依赖安装"><a href="#Hexo依赖安装" class="headerlink" title="Hexo依赖安装"></a>Hexo依赖安装</h2><blockquote><p>Hexo 的安装少不了 Node 和 Git。</p></blockquote><h3 id="安装-Node"><a href="#安装-Node" class="headerlink" title="安装 Node"></a>安装 <a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">Node</a></h3><ul><li>Window 平台（所有平台都可）下载安装包安装</li></ul><p><img src="/2019/01/09/Hexo/Hexo从零开始/image-20190107231333145-6874013.png" alt="Node"></p><ul><li>Mac 平台建议使用 <a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Hombrew</a> 安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装 Homebrew</span><br><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装 node</span><br><span class="line">brew install node</span><br></pre></td></tr></table></figure><ul><li>为加速依赖下载，添加<a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝NPM镜像源</a> ，然后可使用 <code>cnpm</code> 替换 <code>npm</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></h3><ul><li>Window 平台（所有平台都可）下载安装包安装</li></ul><p><img src="/2019/01/09/Hexo/Hexo从零开始/image-20190107232155450-6874515.png" alt="Git"></p><ul><li>Mac 平台建议使用 <a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Hombrew</a> 安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装 Homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line"></span><br><span class="line"># 安装 Git</span><br><span class="line">brew install git</span><br></pre></td></tr></table></figure><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><h3 id="使用命令行工具"><a href="#使用命令行工具" class="headerlink" title="使用命令行工具"></a>使用命令行工具</h3><h4 id="Window-平台"><a href="#Window-平台" class="headerlink" title="Window 平台"></a>Window 平台</h4><ul><li>桌面或者任意文件夹上右键，选择 Git Bash</li></ul><p><img src="/2019/01/09/Hexo/Hexo从零开始/C7F1F26D2359B3DBEFF18FFC92DD25A7.png" alt="Git Bash"></p><h4 id="Mac-平台"><a href="#Mac-平台" class="headerlink" title="Mac 平台"></a>Mac 平台</h4><ul><li>用bash或建议安装 <a href="https://www.iterm2.com/" target="_blank" rel="noopener">iTerm2</a> 终端</li></ul><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 全局安装 hexo</span><br><span class="line">cnpm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 初始化博客</span><br><span class="line">hexo init blog</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 初始文件夹说明</span><br><span class="line">.</span><br><span class="line">├── _config.yml    # 网站的配置信息，可在此配置大部分的参数。</span><br><span class="line">├── package.json   # 应用的依赖配置</span><br><span class="line">├── scaffolds      # 模版文件夹。当新建文章时 Hexo 会根据 scaffold 来建立文件。</span><br><span class="line">├── source         # 存放markdown文件等资源</span><br><span class="line">|   ├── _drafts    # _开头的文件夹会被解析到public文件夹</span><br><span class="line">|   └── _posts     # 其他文件夹会直接被拷贝到public文件夹</span><br><span class="line">└── themes         # 主题文件夹，hexo会根据主题来生成静态页面</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><ul><li>下载 <a href="https://github.com/Molunerfinn/hexo-theme-melody/releases" target="_blank" rel="noopener">Melody</a> 最新版</li><li>解压至 <code>themes/melody</code> 文件夹</li><li>为了方便主题升级, 拷贝  <code>themes/melody/_config.yml</code> 至 <code>source/_data/melody.yml</code></li><li>按<a href="https://molunerfinn.com/hexo-theme-melody-doc/#/" target="_blank" rel="noopener">官方文档</a>进行其他选项配置</li></ul><h3 id="配置-Hexo"><a href="#配置-Hexo" class="headerlink" title="配置 Hexo"></a>配置 Hexo</h3><ul><li>安装主题依赖</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"3.8.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.7.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-asset-image"</span>: <span class="string">"^0.0.3"</span>,</span><br><span class="line">    <span class="attr">"hexo-deployer-git"</span>: <span class="string">"^0.3.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-directory-category"</span>: <span class="string">"^1.0.5"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.5"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.3"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.2.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-search"</span>: <span class="string">"^2.4.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.3.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-jade"</span>: <span class="string">"^0.4.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-kramed"</span>: <span class="string">"^0.1.4"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.3.3"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.3.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-wordcount"</span>: <span class="string">"^6.0.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>按<a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">官方文档</a>进行其他选项配置</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="文章编辑"><a href="#文章编辑" class="headerlink" title="文章编辑"></a>文章编辑</h3><p>编辑 Markdown 文件建议使用 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a> :</p><ul><li><p>设置图片插入时复制到指定路径 <code>./{filename}</code>，对所有图片都应用此规则</p></li><li><p>设置优先使用相对路径</p></li></ul><h3 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h3><ul><li>新建 Markdown 文章</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用命令行，好处是会自动生成元信息</span><br><span class="line">hexo new post "文章标题"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 也可先自行创建文件，后将 scaffolds/post.md 内容添加到文章顶部，然后修改</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 若需要加密，头部添加 password 元信息</span><br><span class="line">password: 123456</span><br></pre></td></tr></table></figure><ul><li>任何时候都可启动本地服务进行预览</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server  # 或简写为 hexo s</span><br></pre></td></tr></table></figure><ul><li>若发现有不生效的情况，需要清除缓存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><ul><li>完成编辑后需要发布</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 生成静态内容</span><br><span class="line">hexo generate  # 或简写为 hexo g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 发布</span><br><span class="line">hexo deploy    # 或简写为hexo d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 发布命令可合并为一条</span><br><span class="line">hexo clean; hexo g; hexo d</span><br></pre></td></tr></table></figure><h3 id="源码版本化管理"><a href="#源码版本化管理" class="headerlink" title="源码版本化管理"></a>源码版本化管理</h3><ul><li>命令行管理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 当新增或修改源码时, 在博客文件夹根目录执行命令</span><br><span class="line">git add .</span><br><span class="line">git commit -m '注释'</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 检查当前工作区</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><ul><li>GUI工具 - <a href="https://www.sublimemerge.com/" target="_blank" rel="noopener">sublime merge</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>相册</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[    <div class="gallery-item" style="background-image: url('/assets/avatar.png')" data-title="avatar" data-url="/assets/avatar.png">      <div class="gallery-item__title">        avatar      </div>    </div>  ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>幻灯片</title>
      <link href="/slides/index.html"/>
      <url>/slides/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
